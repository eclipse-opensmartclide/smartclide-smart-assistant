,codes
0,package Maths;
1,import java.util.Arrays;
4,public class AbsoluteMax {
5,public static void main(String[] args) {
6,int[] testnums = {-2016};
7,assert absMax(testnums) == 16;
8,int[] numbers = {3-10-2};
9,"System.out.println(""absMax("" + Arrays.toString(numbers) + "") = "" + absMax(numbers));"
13,public static int absMax(int[] numbers) {
14,int absMaxValue = numbers[0];
15,for (int i = 1length = numbers.length; i < length; ++i) {
16,if (Math.abs(numbers[i]) > Math.abs(absMaxValue)) {
17,absMaxValue = numbers[i];
18,return absMaxValue;
19,package Maths;
20,import java.util.Arrays;
23,public class AbsoluteMin {
24,public static void main(String[] args) {
25,int[] testnums = {4016};
26,assert absMin(testnums) == 0;
27,int[] numbers = {3-10-2};
28,"System.out.println(""absMin("" + Arrays.toString(numbers) + "") = "" + absMin(numbers));"
32,public static int absMin(int[] numbers) {
33,int absMinValue = numbers[0];
34,for (int i = 1length = numbers.length; i < length; ++i) {
35,if (Math.abs(numbers[i]) < Math.abs(absMinValue)) {
36,absMinValue = numbers[i];
37,return absMinValue;
38,package Maths;
39,import java.util.Random;
40,public class AbsoluteValue {
41,public static void main(String[] args) {
42,Random random = new Random();
44,for (int i = 1; i <= 1000; ++i) {
45,int randomNumber = random.nextInt();
46,assert absVal(randomNumber) == Math.abs(randomNumber);
50,public static int absVal(int value) {
51,return value < 0 ? -value : value;
52,package Maths;
57,public class AliquotSum {
58,public static void main(String[] args) {
59,assert aliquotSum(1) == 0;
60,assert aliquotSum(6) == 6;
61,assert aliquotSum(15) == 9;
62,assert aliquotSum(19) == 1;
66,public static int aliquotSum(int number) {
67,int sum = 0;
68,for (int i = 1limit = number / 2; i <= limit; ++i) {
69,if (number % i == 0) {
70,sum += i;
71,return sum;
72,package Maths;
82,public class AmicableNumber {
83,public static void main(String[] args) {
84,AmicableNumber.findAllInRange(13000);
86,3: = ( 26202924) So it worked	*/
90,static void findAllInRange(int startValueint stopValue) {
94,StringBuilder res = new StringBuilder();
95,int countofRes = 0;
96,for (int i = startValue; i < stopValue; i++) {
97,for (int j = i + 1; j <= stopValue; j++) {
98,if (isAmicableNumber(ij)) {
99,countofRes++;
100,"res.append("""" + countofRes + "": = ( "" + i + """" + j + "")"" + ""\t"");"
101,res.insert(
102,"""Int Range of """
103,+ startValue
104,"+ "" till """
105,+ stopValue
106,"+ "" there are """
107,+ countofRes
108,"+ "" Amicable_numbers.These are \n "");"
109,System.out.println(res.toString());
113,static boolean isAmicableNumber(int numberOneint numberTwo) {
114,return ((recursiveCalcOfDividerSum(numberOnenumberOne) == numberTwo
115,&& numberOne == recursiveCalcOfDividerSum(numberTwonumberTwo)));
119,static int recursiveCalcOfDividerSum(int numberint div) {
120,if (div == 1) {
121,return 0;
122,} else if (number % --div == 0) {
123,return recursiveCalcOfDividerSum(numberdiv) + div;
124,} else {
125,return recursiveCalcOfDividerSum(numberdiv);
126,package Maths;
128,public class Area {
129,public static void main(String[] args) {
131,assert Double.compare(surfaceAreaCube(1)6.0) == 0;
133,assert Double.compare(surfaceAreaSphere(5)314.1592653589793) == 0;
134,assert Double.compare(surfaceAreaSphere(1)12.566370614359172) == 0;
136,assert Double.compare(surfaceAreaRectangle(1020)200.0) == 0;
138,assert Double.compare(surfaceAreaSquare(10)100.0) == 0;
140,assert Double.compare(surfaceAreaTriangle(1010)50.0) == 0;
142,assert Double.compare(surfaceAreaParallelogram(1020)200.0) == 0;
144,assert Double.compare(surfaceAreaTrapezium(102030)450.0) == 0;
146,assert Double.compare(surfaceAreaCircle(20)1256.6370614359173) == 0;
150,private static double surfaceAreaCube(double sideLength) {
151,return 6 * sideLength * sideLength;
155,private static double surfaceAreaSphere(double radius) {
156,return 4 * Math.PI * radius * radius;
161,private static double surfaceAreaRectangle(double lengthdouble width) {
162,return length * width;
166,private static double surfaceAreaSquare(double sideLength) {
167,return sideLength * sideLength;
172,private static double surfaceAreaTriangle(double basedouble height) {
173,return base * height / 2;
178,private static double surfaceAreaParallelogram(double basedouble height) {
179,return base * height;
185,private static double surfaceAreaTrapezium(double base1double base2double height) {
186,return (base1 + base2) * height / 2;
190,private static double surfaceAreaCircle(double radius) {
191,return Math.PI * radius * radius;
192,package Maths;
196,public class Armstrong {
197,public static void main(String[] args) {
198,assert (isArmStrong(0));
199,assert (isArmStrong(1));
200,assert (isArmStrong(153));
201,assert (isArmStrong(1634));
202,assert (isArmStrong(371));
203,assert (!isArmStrong(200));
207,private static boolean isArmStrong(int number) {
208,int sum = 0;
209,int temp = number;
210,int numberOfDigits = 0;
211,while (temp != 0) {
212,numberOfDigits++;
213,temp /= 10;
214,temp = number; /* copy number again */
215,while (number > 0) {
216,int remainder = number % 10;
217,int power = 1;
218,for (int i = 1; i <= numberOfDigits; power *= remainder++i)
219,sum = sum + power;
220,number /= 10;
221,return sum == temp;
222,package Maths;
224,public class Average {
225,private static final double SMALL_VALUE = 0.00001f;
226,public static void main(String[] args) {
227,assert Math.abs(average(new double[] {36912151821}) - 12) < SMALL_VALUE;
228,assert Math.abs(average(new double[] {5101520253035}) - 20) < SMALL_VALUE;
229,assert Math.abs(average(new double[] {12345678}) - 4.5) < SMALL_VALUE;
230,int[] array = {2410};
231,assert average(array) == 5;
235,public static double average(double[] numbers) {
236,double sum = 0;
237,for (double number : numbers) {
238,sum += number;
239,return sum / numbers.length;
243,public static int average(int[] array) {
244,long sum = 0;
245,for (int i = 0; i < array.length; ++i) {
246,sum += array[i];
247,return (int) (sum / array.length);
248,package Maths;
249,public class BinaryPow {
255,public static int binPow(int aint p) {
256,int res = 1;
257,while (p > 0) {
258,if ((p & 1) == 1) {
259,res = res * a;
260,a = a * a;
261,p >>>= 1;
262,return res;
266,public static void test(int aint p) {
267,int res = binPow(ap);
268,"assert res == (int) Math.pow(ap) : ""Incorrect Implementation"";"
269,"System.out.println(a + ""^"" + p + "": "" + res);"
272,public static void main(String[] args) {
274,test(215);
276,test(39);
277,package Maths;
278,import java.util.Random;
279,public class Ceil {
280,public static void main(String[] args) {
281,Random random = new Random();
282,for (int i = 1; i <= 1000; ++i) {
283,double randomNumber = random.nextDouble();
284,assert ceil(randomNumber) == Math.ceil(randomNumber);
288,public static double ceil(double number) {
289,if (number - (int) number == 0) {
290,return number;
291,} else if (number - (int) number > 0) {
292,return (int) (number + 1);
293,} else {
294,return (int) number;
295,package com.maths;
296,import java.util.ArrayList;
300,public class CircularConvolutionFFT {
304,private static void padding(ArrayList<FFT.Complex> xint newSize) {
305,if (x.size() < newSize) {
306,int diff = newSize - x.size();
307,for (int i = 0; i < diff; i++) x.add(new FFT.Complex());
315,public static ArrayList<FFT.Complex> fftCircularConvolution(
316,ArrayList<FFT.Complex> aArrayList<FFT.Complex> b) {
317,int convolvedSize =
318,Math.max(
319,a.size()b.size());
320,padding(aconvolvedSize);
321,padding(bconvolvedSize);
323,FFTBluestein.fftBluestein(afalse);
324,FFTBluestein.fftBluestein(bfalse);
325,ArrayList<FFT.Complex> convolved = new ArrayList<>();
326,for (int i = 0; i < a.size(); i++) convolved.add(a.get(i).multiply(b.get(i)));
327,FFTBluestein.fftBluestein(convolvedtrue);
328,return convolved;
329,import java.io.File;
330,import java.io.FileNotFoundException;
331,import java.util.Scanner;
332,public class ReadFile {
333,public static void main(String[] args) {
334,try {
335,"File myObj = new File(""filename.txt"");"
336,Scanner myReader = new Scanner(myObj);
337,while (myReader.hasNextLine()) {
338,String data = myReader.nextLine();
339,System.out.println(data);
340,myReader.close();
341,} catch (FileNotFoundException e) {
342,"System.out.println(""An error occurred."");"
343,e.printStackTrace();
344,import java.io.File;
345,import java.io.BufferedReader;
346,import java.io.File;
347,import java.io.IOException;
348,import java.io.InputStreamReader;
349,class fileProperty
350,public static void main(String[] args) {
351,String fname =args[0];
352,File f = new File(fname);
353,"System.out.println(""File name :""+f.getName());"
354,"System.out.println(""Path: ""+f.getPath());"
355,"System.out.println(""Absolute path:"" +f.getAbsolutePath());"
356,"System.out.println(""Parent:""+f.getParent());"
357,"System.out.println(""Exists :""+f.exists());"
358,if(f.exists())
359,"System.out.println(""Is writeable:""+f.canWrite());"
360,"System.out.println(""Is readable""+f.canRead());"
361,"System.out.println(""Is a directory:""+f.isDirectory());"
362,"System.out.println(""File Size in bytes ""+f.length());"
363,import java.io.BufferedReader;
364,import java.io.File;
365,import java.io.IOException;
366,import java.io.InputStreamReader;
367,class Contents
368,public static void main(String[] args) throws IOException {
369,BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
370,"System.out.println(""Enter dirpath:"");"
371,String dirpath=br.readLine();
372,"System.out.println(""Enter the dirname"");"
373,String dname=br.readLine();
374,File f = new File(dirpathdname);
375,if(f.exists())
376,String arr[]=f.list();
377,int n=arr.length;
378,for (int i = 0; i < n ; i++) {
379,System.out.println(arr[i]);
380,File f1=new File(arr[i]);
381,if(f1.isFile())
382,"System.out.println("": is a file"");"
383,if(f1.isDirectory())
384,"System.out.println("": is a directory"");"
385,"System.out.println(""No of entries in this directory ""+n);"
386,else
387,"System.out.println(""Directory not found"");"
388,import com.google.common.jimfs.Configuration;
389,import com.google.common.jimfs.Jimfs;
390,import java.io.IOException;
391,import java.nio.file.FileSystem;
392,import java.nio.file.Files;
393,import java.nio.file.Path;
394,public class JimFSSystem {
395,public static void main(String[] args) throws IOException {
396,try (FileSystem fileSystem = Jimfs.newFileSystem(Configuration.unix());) {
397,"Path inMemoryFile = fileSystem.getPath(""/tmp/somefile.txt"");"
398,"Files.writeString(inMemoryFile""Hello World"");"
399,System.out.println(Files.readString(inMemoryFile));
400,import com.github.marschall.memoryfilesystem.MemoryFileSystemBuilder;
401,import java.io.IOException;
402,import java.nio.file.FileSystem;
403,import java.nio.file.Files;
404,import java.nio.file.Path;
405,public class MemoryFileSystem {
406,public static void main(String[] args) throws IOException {
407,try (FileSystem fileSystem = MemoryFileSystemBuilder.newMacOs().build()) {
408,"Path inMemoryFile = fileSystem.getPath(""/somefile.txt"");"
409,"Files.writeString(inMemoryFile""Hello World"");"
410,System.out.println(Files.readString(inMemoryFile));
411,import java.io.File;
412,import java.nio.file.Files;
413,import java.nio.file.Path;
414,File file = getYourFile();
415,Path path = file.toPath();
416,byte[] data = Files.readAllBytes(path);
417,import java.io.File;
418,import java.io.FileNotFoundException;
419,import java.util.Scanner;
420,public class ReadFile {
421,public static void main(String[] args) {
422,try {
423,"File myObj = new File(""filename.txt"");"
424,Scanner myReader = new Scanner(myObj);
425,while (myReader.hasNextLine()) {
426,String data = myReader.nextLine();
427,System.out.println(data);
428,myReader.close();
429,} catch (FileNotFoundException e) {
430,"System.out.println(""An error occurred."");"
431,e.printStackTrace();
432,import java.io.File;
433,import java.io.BufferedReader;
434,import java.io.File;
435,import java.io.IOException;
436,import java.io.InputStreamReader;
437,class fileProperty
438,public static void main(String[] args) {
439,String fname =args[0];
440,File f = new File(fname);
441,"System.out.println(""File name :""+f.getName());"
442,"System.out.println(""Path: ""+f.getPath());"
443,"System.out.println(""Absolute path:"" +f.getAbsolutePath());"
444,"System.out.println(""Parent:""+f.getParent());"
445,"System.out.println(""Exists :""+f.exists());"
446,if(f.exists())
447,"System.out.println(""Is writeable:""+f.canWrite());"
448,"System.out.println(""Is readable""+f.canRead());"
449,"System.out.println(""Is a directory:""+f.isDirectory());"
450,"System.out.println(""File Size in bytes ""+f.length());"
451,import java.io.BufferedReader;
452,import java.io.File;
453,import java.io.IOException;
454,import java.io.InputStreamReader;
455,class Contents
456,public static void main(String[] args) throws IOException {
457,BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
458,"System.out.println(""Enter dirpath:"");"
459,String dirpath=br.readLine();
460,"System.out.println(""Enter the dirname"");"
461,String dname=br.readLine();
462,File f = new File(dirpathdname);
463,if(f.exists())
464,String arr[]=f.list();
465,int n=arr.length;
466,for (int i = 0; i < n ; i++) {
467,System.out.println(arr[i]);
468,File f1=new File(arr[i]);
469,if(f1.isFile())
470,"System.out.println("": is a file"");"
471,if(f1.isDirectory())
472,"System.out.println("": is a directory"");"
473,"System.out.println(""No of entries in this directory ""+n);"
474,else
475,"System.out.println(""Directory not found"");"
476,import com.google.common.jimfs.Configuration;
477,import com.google.common.jimfs.Jimfs;
478,import java.io.IOException;
479,import java.nio.file.FileSystem;
480,import java.nio.file.Files;
481,import java.nio.file.Path;
482,public class JimFSSystem {
483,public static void main(String[] args) throws IOException {
484,try (FileSystem fileSystem = Jimfs.newFileSystem(Configuration.unix());) {
485,"Path inMemoryFile = fileSystem.getPath(""/tmp/somefile.txt"");"
486,"Files.writeString(inMemoryFile""Hello World"");"
487,System.out.println(Files.readString(inMemoryFile));
488,import com.github.marschall.memoryfilesystem.MemoryFileSystemBuilder;
489,import java.io.IOException;
490,import java.nio.file.FileSystem;
491,import java.nio.file.Files;
492,import java.nio.file.Path;
493,public class MemoryFileSystem {
494,public static void main(String[] args) throws IOException {
495,try (FileSystem fileSystem = MemoryFileSystemBuilder.newMacOs().build()) {
496,"Path inMemoryFile = fileSystem.getPath(""/somefile.txt"");"
497,"Files.writeString(inMemoryFile""Hello World"");"
498,System.out.println(Files.readString(inMemoryFile));
499,import java.io.File;
500,import java.nio.file.Files;
501,import java.nio.file.Path;
502,File file = getYourFile();
503,Path path = file.toPath();
504,byte[] data = Files.readAllBytes(path);
505,import java.io.*;
506,import javax.swing.JButton;
507,import javax.swing.JFrame;
508,import javax.swing.WindowConstants;
509,import javax.swing.ButtonModel;
510,import javax.swing.JButton;
511,import javax.swing.JOptionPane;
512,import javax.swing.event.ChangeEvent;
513,import javax.swing.event.ChangeListener;
514,import java.awt.Dimension;
515,import java.awt.Graphics;
516,import java.awt.Image;
517,import javax.swing.ImageIcon;
518,import javax.swing.JFrame;
519,import javax.swing.JPanel;
520,import java.awt.DisplayMode;
521,import java.awt.GraphicsDevice;
522,import java.awt.GraphicsEnvironment;
523,import javax.swing.JButton;
524,import javax.swing.JFrame;
525,import javax.swing.JOptionPane;
526,import javax.swing.JPanel;
527,import java.awt.BorderLayout;
528,import java.awt.Dimension;
529,import java.awt.FlowLayout;
530,import java.awt.GridBagLayout;
531,import java.awt.GridLayout;
532,import java.awt.event.ActionEvent;
533,import java.awt.event.ActionListener;
534,import javax.swing.JButton;
535,import javax.swing.JCheckBox;
536,import javax.swing.JComboBox;
537,import javax.swing.JFrame;
538,import javax.swing.JLabel;
539,import javax.swing.JPanel;
540,import javax.swing.JScrollPane;
541,import javax.swing.JSplitPane;
542,import javax.swing.JTable;
543,import javax.swing.SwingUtilities;
544,import javax.swing.UIManager;
545,import javax.swing.border.TitledBorder;
546,import javax.swing.table.DefaultTableModel;
547,import java.awt.DisplayMode;
548,import java.awt.GraphicsDevice;
549,import java.awt.GraphicsEnvironment;
550,import java.awt.event.WindowAdapter;
551,import java.awt.event.WindowEvent;
552,import javax.swing.JButton;
553,import javax.swing.JFrame;
554,import javax.swing.JOptionPane;
555,import javax.swing.JPanel;
556,import java.io.*;
557,import javax.swing.JButton;
558,import javax.swing.JFrame;
559,import javax.swing.WindowConstants;
560,import javax.swing.ButtonModel;
561,import javax.swing.JButton;
562,import javax.swing.JOptionPane;
563,import javax.swing.event.ChangeEvent;
564,import javax.swing.event.ChangeListener;
565,import java.awt.Dimension;
566,import java.awt.Graphics;
567,import java.awt.Image;
568,import javax.swing.ImageIcon;
569,import javax.swing.JFrame;
570,import javax.swing.JPanel;
571,import java.awt.DisplayMode;
572,import java.awt.GraphicsDevice;
573,import java.awt.GraphicsEnvironment;
574,import javax.swing.JButton;
575,import javax.swing.JFrame;
576,import javax.swing.JOptionPane;
577,import javax.swing.JPanel;
578,import java.awt.BorderLayout;
579,import java.awt.Dimension;
580,import java.awt.FlowLayout;
581,import java.awt.GridBagLayout;
582,import java.awt.GridLayout;
583,import java.awt.event.ActionEvent;
584,import java.awt.event.ActionListener;
585,import javax.swing.JButton;
586,import javax.swing.JCheckBox;
587,import javax.swing.JComboBox;
588,import javax.swing.JFrame;
589,import javax.swing.JLabel;
590,import javax.swing.JPanel;
591,import javax.swing.JScrollPane;
592,import javax.swing.JSplitPane;
593,import javax.swing.JTable;
594,import javax.swing.SwingUtilities;
595,import javax.swing.UIManager;
596,import javax.swing.border.TitledBorder;
597,import javax.swing.table.DefaultTableModel;
598,import java.awt.DisplayMode;
599,import java.awt.GraphicsDevice;
600,import java.awt.GraphicsEnvironment;
601,import java.awt.event.WindowAdapter;
602,import java.awt.event.WindowEvent;
603,import javax.swing.JButton;
604,import javax.swing.JFrame;
605,import javax.swing.JOptionPane;
606,import javax.swing.JPanel;
607,public class Main {
608,private static boolean programmatic = false;
609,public static void main(String[] args) {
610,JFrame frame = new JFrame();
611,frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
612,GraphicsDevice device = GraphicsEnvironment.getLocalGraphicsEnvironment()
613,.getDefaultScreenDevice();
614,device.setFullScreenWindow(frame);
615,device.setDisplayMode(new DisplayMode(8006003260));
616,frame.addWindowListener(new WindowAdapter() {
618,public void windowIconified(WindowEvent we) {
619,if (programmatic) {
620,programmatic = false;
621,frame.setState(JFrame.NORMAL);
622,JButton btn = new JButton();
623,"btn.setText(""Btn"");"
624,final JPanel panel = new JPanel();
625,panel.add(btn);
626,frame.add(panel);
627,btn.addActionListener(e -> {
628,programmatic = true;
629,"JOptionPane.showMessageDialog(panel""Sample"");"
630,frame.setVisible(true);
631,import java.io.File;
632,import javax.swing.JFileChooser;
633,import javax.swing.JOptionPane;
634,import javax.swing.SwingUtilities;
635,import javax.swing.UIManager;
636,import javax.swing.filechooser.FileFilter;
637,import java.io.File;
638,import javax.swing.JFileChooser;
639,import javax.swing.JOptionPane;
640,import javax.swing.SwingUtilities;
641,import javax.swing.UIManager;
642,import javax.swing.filechooser.FileFilter;
643,public class Main {
644,public static void main(String[] args) throws Exception {
645,"String[] properties = { ""os.name""""java.version""""java.vm.version"""
646,"""java.vendor"" };"
647,for (String property : properties) {
648,"System.out.println(property + "": "" + System.getProperty(property));"
649,JFileChooser jfc = new JFileChooser();
650,jfc.showOpenDialog(null);
651,jfc.addChoosableFileFilter(new FileFilter() {
653,public boolean accept(File f) {
654,"return f.isDirectory() || f.getName().toLowerCase().endsWith("".obj"");"
656,public String getDescription() {
657,"return ""Wavefront OBJ (*.obj)"";"
659,public String toString() {
660,return getDescription();
661,int result = JOptionPane.showConfirmDialog(null
662,"""Description was 'All Files'?"");"
663,UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
664,SwingUtilities.updateComponentTreeUI(jfc);
665,jfc.showOpenDialog(null);
666,result = JOptionPane
667,".showConfirmDialog(null""Description was 'All Files'?"");"
668,result = JOptionPane
669,".showConfirmDialog(null""Description was 'All Files'?"");"
670,for (UIManager.LookAndFeelInfo info : javax.swing.UIManager
671,.getInstalledLookAndFeels()) {
672,"if (""Nimbus"".equals(info.getName())) {"
673,UIManager.setLookAndFeel(info.getClassName());
674,SwingUtilities.updateComponentTreeUI(jfc);
675,break;
676,jfc.showOpenDialog(null);
677,result = JOptionPane
678,".showConfirmDialog(null""Description was 'All Files'?"");"
679,import java.awt.BorderLayout;
680,import javax.swing.JFrame;
681,import javax.swing.JPanel;
682,import javax.swing.plaf.basic.BasicArrowButton;
683,import java.awt.BorderLayout;
684,import javax.swing.JFrame;
685,import javax.swing.JPanel;
686,import javax.swing.plaf.basic.BasicArrowButton;
687,public class Main extends JPanel {
688,public Main() {
689,setLayout(new BorderLayout());
690,JPanel east = new JPanel(new BorderLayout());
691,add(eastBorderLayout.EAST);
692,BasicArrowButton north = new BasicArrowButton(BasicArrowButton.NORTH);
693,east.add(northBorderLayout.NORTH);
694,BasicArrowButton south = new BasicArrowButton(BasicArrowButton.SOUTH);
695,east.add(southBorderLayout.SOUTH);
696,public static void main(String[] args) {
697,"JFrame frame = new JFrame(""Main"");"
698,frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
699,frame.add(new Main());
700,frame.setSize(200300);
701,frame.setLocationByPlatform(true);
702,frame.setVisible(true);
703,import javax.swing.JFrame;
704,import javax.swing.JPanel;
705,import javax.swing.JRootPane;
706,import javax.swing.SwingUtilities;
707,import javax.swing.UIManager;
708,import javax.swing.plaf.ColorUIResource;
709,import javax.swing.plaf.metal.DefaultMetalTheme;
710,import javax.swing.plaf.metal.MetalLookAndFeel;
711,import javax.swing.JFrame;
712,import javax.swing.JPanel;
713,import javax.swing.JRootPane;
714,import javax.swing.SwingUtilities;
715,import javax.swing.UIManager;
716,import javax.swing.plaf.ColorUIResource;
717,import javax.swing.plaf.metal.DefaultMetalTheme;
718,import javax.swing.plaf.metal.MetalLookAndFeel;
719,public class Main {
720,public static void main_helper(String args[]) {
721,JFrame f = new JFrame();
722,f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
723,f.setSize(300300);
724,f.setUndecorated(true);
725,f.getRootPane().setWindowDecorationStyle(JRootPane.FRAME);
726,JPanel panel = new JPanel();
727,panel.setBackground(java.awt.Color.white);
728,f.setContentPane(panel);
729,MetalLookAndFeel.setCurrentTheme(new MyDefaultMetalTheme());
730,try {
731,UIManager.setLookAndFeel(new MetalLookAndFeel());
732,} catch (Exception e) {
733,e.printStackTrace();
734,SwingUtilities.updateComponentTreeUI(f);
735,f.setVisible(true);
736,public static void main(final String args[]) {
737,main_helper(args);
738,class MyDefaultMetalTheme extends DefaultMetalTheme {
739,public ColorUIResource getWindowTitleInactiveBackground() {
740,return new ColorUIResource(java.awt.Color.orange);
741,public ColorUIResource getWindowTitleBackground() {
742,return new ColorUIResource(java.awt.Color.orange);
743,public ColorUIResource getPrimaryControlHighlight() {
744,return new ColorUIResource(java.awt.Color.orange);
745,public ColorUIResource getPrimaryControlDarkShadow() {
746,return new ColorUIResource(java.awt.Color.orange);
747,public ColorUIResource getPrimaryControl() {
748,return new ColorUIResource(java.awt.Color.orange);
749,public ColorUIResource getControlHighlight() {
750,return new ColorUIResource(java.awt.Color.orange);
751,public ColorUIResource getControlDarkShadow() {
752,return new ColorUIResource(java.awt.Color.orange);
753,public ColorUIResource getControl() {
754,return new ColorUIResource(java.awt.Color.orange);
755,public class TextIO {
756,public static void put(int x)     { put(x0); }
757,public static void put(long x)    { put(x0); }
758,public static void put(double x)  { put(x0); }
759,public static void put(char x)    { put(x0); }
760,public static void put(boolean x) { put(x0); }
761,public static void put(String x)  { put(x0); }
762,public static void putln(int x)      { put(x0); newLine(); }
763,public static void putln(long x)     { put(x0); newLine(); }
764,public static void putln(double x)   { put(x0); newLine(); }
765,public static void putln(char x)     { put(x0); newLine(); }
766,public static void putln(boolean x)  { put(x0); newLine(); }
767,public static void putln(String x)   { put(x0); newLine(); }
768,public static void putln(int xint w)     { put(xw); newLine(); }
769,public static void putln(long xint w)    { put(xw); newLine(); }
770,public static void putln(double xint w)  { put(xw); newLine(); }
771,public static void putln(char xint w)    { put(xw); newLine(); }
772,public static void putln(boolean xint w) { put(xw); newLine(); }
773,public static void putln(String xint w)  { put(xw); newLine(); }
774,public static void putln() { newLine(); }
775,public static void put(int xint w)     { dumpString(String.valueOf(x)w); }
776,public static void put(long xint w)    { dumpString(String.valueOf(x)w); }
777,public static void put(double xint w)  { dumpString(realToString(x)w); }
778,public static void put(char xint w)    { dumpString(String.valueOf(x)w); }
779,public static void put(boolean xint w) { dumpString(String.valueOf(x)w); }
780,public static void put(String xint w)  { dumpString(xw); }
781,public static byte getlnByte()       { byte x=getByte();       emptyBuffer();  return x; }
782,public static short getlnShort()     { short x=getShort();     emptyBuffer();  return x; }
783,public static int getlnInt()         { int x=getInt();         emptyBuffer();  return x; }
784,public static long getlnLong()       { long x=getLong();       emptyBuffer();  return x; }
785,public static float getlnFloat()     { float x=getFloat();     emptyBuffer();  return x; }
786,public static double getlnDouble()   { double x=getDouble();   emptyBuffer();  return x; }
787,public static char getlnChar()       { char x=getChar();       emptyBuffer();  return x; }
788,public static boolean getlnBoolean() { boolean x=getBoolean(); emptyBuffer();  return x; }
789,public static String getlnWord()     { String x=getWord();     emptyBuffer();  return x; }
790,public static String getlnString()   { return getln(); }
791,public static String getln() {
792,StringBuffer s = new StringBuffer(100);
793,char ch = readChar();
794,while (ch != '\n') {
795,s.append(ch);
796,ch = readChar();
797,return s.toString();
798,public static byte getByte()   { return (byte)readInteger(-128L127L); }
799,public static short getShort() { return (short)readInteger(-32768L32767L); }
800,public static int getInt()     { return (int)readInteger((long)Integer.MIN_VALUE(long)Integer.MAX_VALUE); }
801,public static long getLong()   { return readInteger(Long.MIN_VALUELong.MAX_VALUE); }
802,public static char getAnyChar(){ return readChar(); }
803,public static char peek()      { return lookChar(); }
804,public static char getChar() {
805,char ch = lookChar();
806,while (ch == ' ' || ch == '\n') {
807,readChar();
808,if (ch == '\n')
809,"dumpString(""? ""0);"
810,ch = lookChar();
811,return readChar();
812,public static float getFloat() {
813,float x = 0.0F;
814,while (true) {
815,String str = readRealString();
816,"if (str.equals("""")) {"
817,"errorMessage(""Illegal floating point input."""
818,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
819,else {
820,Float f = null;
821,try { f = Float.valueOf(str); }
822,catch (NumberFormatException e) {
823,"errorMessage(""Illegal floating point input."""
824,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
825,continue;
826,if (f.isInfinite()) {
827,"errorMessage(""Floating point input outside of legal range."""
828,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
829,continue;
830,x = f.floatValue();
831,break;
832,return x;
833,public static double getDouble() {
834,double x = 0.0;
835,while (true) {
836,String str = readRealString();
837,"if (str.equals("""")) {"
838,"errorMessage(""Illegal floating point input"""
839,"""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
840,else {
841,Double f = null;
842,try { f = Double.valueOf(str); }
843,catch (NumberFormatException e) {
844,"errorMessage(""Illegal floating point input"""
845,"""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
846,continue;
847,if (f.isInfinite()) {
848,"errorMessage(""Floating point input outside of legal range.""""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
849,continue;
850,x = f.doubleValue();
851,break;
852,return x;
853,public static String getWord() {
854,char ch = lookChar();
855,while (ch == ' ' || ch == '\n') {
856,readChar();
857,if (ch == '\n')
858,"dumpString(""? ""0);"
859,ch = lookChar();
860,StringBuffer str = new StringBuffer(50);
861,while (ch != ' ' && ch != '\n') {
862,str.append(readChar());
863,ch = lookChar();
864,return str.toString();
865,public static boolean getBoolean() {
866,boolean ans = false;
867,while (true) {
868,String s = getWord();
869,"if ( s.equalsIgnoreCase(""true"") || s.equalsIgnoreCase(""t"") || s.equalsIgnoreCase(""yes"")  || s.equalsIgnoreCase(""y"") || s.equals(""1"") ) {"
870,ans = true;
871,break;
872,"else if ( s.equalsIgnoreCase(""false"") || s.equalsIgnoreCase(""f"") || s.equalsIgnoreCase(""no"")  || s.equalsIgnoreCase(""n"") || s.equals(""0"") ) {"
873,ans = false;
874,break;
875,else
876,"errorMessage(""Illegal boolean input value.""""one of:  truefalsetfyesnoyn0or 1"");"
877,return ans;
878,private static InputStream in = System.in;
879,private static PrintStream out = System.out;
880,private static String buffer = null;
881,private static int pos = 0;
882,private static String readRealString() {
883,StringBuffer s=new StringBuffer(50);
884,char ch=lookChar();
885,while (ch == ' ' || ch == '\n') {
886,readChar();
887,if (ch == '\n')
888,"dumpString(""? ""0);"
889,ch = lookChar();
890,if (ch == '-' || ch == '+') {
891,s.append(readChar());
892,ch = lookChar();
893,while (ch == ' ') {
894,readChar();
895,ch = lookChar();
896,while (ch >= '0' && ch <= '9') {
897,s.append(readChar());
898,ch = lookChar();
899,if (ch == '.') {
900,s.append(readChar());
901,ch = lookChar();
902,while (ch >= '0' && ch <= '9') {
903,s.append(readChar());
904,ch = lookChar();
905,if (ch == 'E' || ch == 'e') {
906,s.append(readChar());
907,ch = lookChar();
908,if (ch == '-' || ch == '+') {
909,s.append(readChar());
910,ch = lookChar();
911,while (ch >= '0' && ch <= '9') {
912,s.append(readChar());
913,ch = lookChar();
914,return s.toString();
915,private static long readInteger(long minlong max) {
916,long x=0;
917,while (true) {
918,StringBuffer s=new StringBuffer(34);
919,char ch=lookChar();
920,while (ch == ' ' || ch == '\n') {
921,readChar();
922,if (ch == '\n');
923,"dumpString(""? ""0);"
924,ch = lookChar();
925,if (ch == '-' || ch == '+') {
926,s.append(readChar());
927,ch = lookChar();
928,while (ch == ' ') {
929,readChar();
930,ch = lookChar();
931,while (ch >= '0' && ch <= '9') {
932,s.append(readChar());
933,ch = lookChar();
934,"if (s.equals("""")){"
935,"errorMessage(""Illegal integer input."""
936,"""Integer in the range "" + min + "" to "" + max);"
937,else {
938,String str = s.toString();
939,try {
940,x = Long.parseLong(str);
941,catch (NumberFormatException e) {
942,"errorMessage(""Illegal integer input."""
943,"""Integer in the range "" + min + "" to "" + max);"
944,continue;
945,if (x < min || x > max) {
946,"errorMessage(""Integer input outside of legal range."""
947,"""Integer in the range "" + min + "" to "" + max);"
948,continue;
949,break;
950,return x;
951,private static String realToString(double x) {
952,if (Double.isNaN(x))
953,"return ""undefined"";"
954,if (Double.isInfinite(x))
955,if (x < 0)
956,"return ""-INF"";"
957,else
958,"return ""INF"";"
959,if (Math.abs(x) <= 5000000000.0 && Math.rint(x) == x)
960,return String.valueOf( (long)x );
961,String s = String.valueOf(x);
962,if (s.length() <= 10)
963,return s;
964,boolean neg = false;
965,if (x < 0) {
966,neg = true;
967,x = -x;
968,s = String.valueOf(x);
969,if (x >= 0.00005 && x <= 50000000 && (s.indexOf('E') == -1 && s.indexOf('e') == -1)) {
970,s = round(s10);
971,s = trimZeros(s);
972,else if (x > 1) {
973,long power = (long)Math.floor(Math.log(x)/Math.log(10));
974,"String exp = ""E"" + power;"
975,int numlength = 10 - exp.length();
976,x = x / Math.pow(10power);
977,s = String.valueOf(x);
978,s = round(snumlength);
979,s = trimZeros(s);
980,s += exp;
981,else {
982,long power = (long)Math.ceil(-Math.log(x)/Math.log(10));
983,"String exp = ""E-"" + power;"
984,int numlength = 10 - exp.length();
985,x = x * Math.pow(10power);
986,s = String.valueOf(x);
987,s = round(snumlength);
988,s = trimZeros(s);
989,s += exp;
990,if (neg)
991,"return ""-"" + s;"
992,else
993,return s;
994,private static String trimZeros(String num) {
995,if (num.indexOf('.') >= 0 && num.charAt(num.length() - 1) == '0') {
996,int i = num.length() - 1;
997,while (num.charAt(i) == '0')
998,i--;
999,if (num.charAt(i) == '.')
1000,num = num.substring(0i);
1001,else
1002,num = num.substring(0i+1);
1003,return num;
1004,private static String round(String numint length) {
1005,if (num.indexOf('.') < 0)
1006,return num;
1007,if (num.length() <= length)
1008,return num;
1009,if (num.charAt(length) >= '5' && num.charAt(length) != '.') {
1010,char[] temp = new char[length+1];
1011,int ct = length;
1012,boolean rounding = true;
1013,for (int i = length-1; i >= 0; i--) {
1014,temp[ct] = num.charAt(i);
1015,if (rounding && temp[ct] != '.') {
1016,if (temp[ct] < '9') {
1017,temp[ct]++;
1018,rounding = false;
1019,else
1020,temp[ct] = '0';
1021,ct--;
1022,if (rounding) {
1023,temp[ct] = '1';
1024,ct--;
1025,return new String(tempct+1length-ct);
1026,else
1027,return num.substring(0length);
1028,private static void dumpString(String strint w) {
1029,for (int i=str.length(); i<w; i++)
1030,out.print(' ');
1031,for (int i=0; i<str.length(); i++)
1032,if ((int)str.charAt(i) >= 0x20 && (int)str.charAt(i) != 0x7F)
1033,out.print(str.charAt(i));
1034,else if (str.charAt(i) == '\n' || str.charAt(i) == '\r')
1035,newLine();
1036,private static void errorMessage(String messageString expecting) {
1037,newLine();
1038,"dumpString(""  *** Error in input: "" + message + ""\n""0);"
1039,"dumpString(""  *** Expecting: "" + expecting + ""\n""0);"
1040,"dumpString(""  *** Discarding Input: ""0);"
1041,if (lookChar() == '\n')
1042,"dumpString(""(end-of-line)\n\n""0);"
1043,else {
1044,while (lookChar() != '\n')
1045,out.print(readChar());
1046,"dumpString(""\n\n""0);"
1047,"dumpString(""Please re-enter: ""0);"
1048,readChar();
1049,private static char lookChar() {
1050,if (buffer == null || pos > buffer.length())
1051,fillBuffer();
1052,if (pos == buffer.length())
1053,return '\n';
1054,return buffer.charAt(pos);
1055,private static char readChar() {
1056,char ch = lookChar();
1057,pos++;
1058,return ch;
1059,private static void newLine() {
1060,out.println();
1061,out.flush();
1062,private static boolean possibleLinefeedPending = false;
1063,private static void fillBuffer() {
1064,StringBuffer b = new StringBuffer();
1065,out.flush();
1066,try {
1067,int ch = in.read();
1068,if (ch == '\n' && possibleLinefeedPending)
1069,ch = in.read();
1070,possibleLinefeedPending = false;
1071,while (ch != -1 && ch != '\n' && ch != '\r') {
1072,b.append((char)ch);
1073,ch = in.read();
1074,possibleLinefeedPending = (ch == '\r');
1075,if (ch == -1) {
1076,"System.out.println(""\n*** Found an end-of-file while trying to read from standard input!"");"
1077,"System.out.println(""*** Maybe your Java system doesn't implement standard input?"");"
1078,"System.out.println(""*** Program will be terminated.\n"");"
1079,"throw new RuntimeException(""End-of-file on standard input."");"
1080,catch (IOException e) {
1081,"System.out.println(""Unexpected system error on input."");"
1082,"System.out.println(""Terminating program."");"
1083,System.exit(1);
1084,buffer = b.toString();
1085,pos = 0;
1086,private static void emptyBuffer() {
1087,buffer = null;
1088,import java.io.*;
1089,import javax.swing.JButton;
1090,import javax.swing.JFrame;
1091,import javax.swing.WindowConstants;
1092,import javax.swing.ButtonModel;
1093,import javax.swing.JButton;
1094,import javax.swing.JOptionPane;
1095,import javax.swing.event.ChangeEvent;
1096,import javax.swing.event.ChangeListener;
1097,import java.awt.Dimension;
1098,import java.awt.Graphics;
1099,import java.awt.Image;
1100,import javax.swing.ImageIcon;
1101,import javax.swing.JFrame;
1102,import javax.swing.JPanel;
1103,import java.awt.DisplayMode;
1104,import java.awt.GraphicsDevice;
1105,import java.awt.GraphicsEnvironment;
1106,import javax.swing.JButton;
1107,import javax.swing.JFrame;
1108,import javax.swing.JOptionPane;
1109,import javax.swing.JPanel;
1110,import java.awt.BorderLayout;
1111,import java.awt.Dimension;
1112,import java.awt.FlowLayout;
1113,import java.awt.GridBagLayout;
1114,import java.awt.GridLayout;
1115,import java.awt.event.ActionEvent;
1116,import java.awt.event.ActionListener;
1117,import javax.swing.JButton;
1118,import javax.swing.JCheckBox;
1119,import javax.swing.JComboBox;
1120,import javax.swing.JFrame;
1121,import javax.swing.JLabel;
1122,import javax.swing.JPanel;
1123,import javax.swing.JScrollPane;
1124,import javax.swing.JSplitPane;
1125,import javax.swing.JTable;
1126,import javax.swing.SwingUtilities;
1127,import javax.swing.UIManager;
1128,import javax.swing.border.TitledBorder;
1129,import javax.swing.table.DefaultTableModel;
1130,import java.awt.DisplayMode;
1131,import java.awt.GraphicsDevice;
1132,import java.awt.GraphicsEnvironment;
1133,import java.awt.event.WindowAdapter;
1134,import java.awt.event.WindowEvent;
1135,import javax.swing.JButton;
1136,import javax.swing.JFrame;
1137,import javax.swing.JOptionPane;
1138,import javax.swing.JPanel;
1139,import java.io.*;
1140,import javax.swing.JButton;
1141,import javax.swing.JFrame;
1142,import javax.swing.WindowConstants;
1143,import javax.swing.ButtonModel;
1144,import javax.swing.JButton;
1145,import javax.swing.JOptionPane;
1146,import javax.swing.event.ChangeEvent;
1147,import javax.swing.event.ChangeListener;
1148,import java.awt.Dimension;
1149,import java.awt.Graphics;
1150,import java.awt.Image;
1151,import javax.swing.ImageIcon;
1152,import javax.swing.JFrame;
1153,import javax.swing.JPanel;
1154,import java.awt.DisplayMode;
1155,import java.awt.GraphicsDevice;
1156,import java.awt.GraphicsEnvironment;
1157,import javax.swing.JButton;
1158,import javax.swing.JFrame;
1159,import javax.swing.JOptionPane;
1160,import javax.swing.JPanel;
1161,import java.awt.BorderLayout;
1162,import java.awt.Dimension;
1163,import java.awt.FlowLayout;
1164,import java.awt.GridBagLayout;
1165,import java.awt.GridLayout;
1166,import java.awt.event.ActionEvent;
1167,import java.awt.event.ActionListener;
1168,import javax.swing.JButton;
1169,import javax.swing.JCheckBox;
1170,import javax.swing.JComboBox;
1171,import javax.swing.JFrame;
1172,import javax.swing.JLabel;
1173,import javax.swing.JPanel;
1174,import javax.swing.JScrollPane;
1175,import javax.swing.JSplitPane;
1176,import javax.swing.JTable;
1177,import javax.swing.SwingUtilities;
1178,import javax.swing.UIManager;
1179,import javax.swing.border.TitledBorder;
1180,import javax.swing.table.DefaultTableModel;
1181,import java.awt.DisplayMode;
1182,import java.awt.GraphicsDevice;
1183,import java.awt.GraphicsEnvironment;
1184,import java.awt.event.WindowAdapter;
1185,import java.awt.event.WindowEvent;
1186,import javax.swing.JButton;
1187,import javax.swing.JFrame;
1188,import javax.swing.JOptionPane;
1189,import javax.swing.JPanel;
1190,public class Main {
1191,private static boolean programmatic = false;
1192,public static void main(String[] args) {
1193,JFrame frame = new JFrame();
1194,frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
1195,GraphicsDevice device = GraphicsEnvironment.getLocalGraphicsEnvironment()
1196,.getDefaultScreenDevice();
1197,device.setFullScreenWindow(frame);
1198,device.setDisplayMode(new DisplayMode(8006003260));
1199,frame.addWindowListener(new WindowAdapter() {
1201,public void windowIconified(WindowEvent we) {
1202,if (programmatic) {
1203,programmatic = false;
1204,frame.setState(JFrame.NORMAL);
1205,JButton btn = new JButton();
1206,"btn.setText(""Btn"");"
1207,final JPanel panel = new JPanel();
1208,panel.add(btn);
1209,frame.add(panel);
1210,btn.addActionListener(e -> {
1211,programmatic = true;
1212,"JOptionPane.showMessageDialog(panel""Sample"");"
1213,frame.setVisible(true);
1214,import java.io.File;
1215,import javax.swing.JFileChooser;
1216,import javax.swing.JOptionPane;
1217,import javax.swing.SwingUtilities;
1218,import javax.swing.UIManager;
1219,import javax.swing.filechooser.FileFilter;
1220,import java.io.File;
1221,import javax.swing.JFileChooser;
1222,import javax.swing.JOptionPane;
1223,import javax.swing.SwingUtilities;
1224,import javax.swing.UIManager;
1225,import javax.swing.filechooser.FileFilter;
1226,public class Main {
1227,public static void main(String[] args) throws Exception {
1228,"String[] properties = { ""os.name""""java.version""""java.vm.version"""
1229,"""java.vendor"" };"
1230,for (String property : properties) {
1231,"System.out.println(property + "": "" + System.getProperty(property));"
1232,JFileChooser jfc = new JFileChooser();
1233,jfc.showOpenDialog(null);
1234,jfc.addChoosableFileFilter(new FileFilter() {
1236,public boolean accept(File f) {
1237,"return f.isDirectory() || f.getName().toLowerCase().endsWith("".obj"");"
1239,public String getDescription() {
1240,"return ""Wavefront OBJ (*.obj)"";"
1242,public String toString() {
1243,return getDescription();
1244,int result = JOptionPane.showConfirmDialog(null
1245,"""Description was 'All Files'?"");"
1246,UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
1247,SwingUtilities.updateComponentTreeUI(jfc);
1248,jfc.showOpenDialog(null);
1249,result = JOptionPane
1250,".showConfirmDialog(null""Description was 'All Files'?"");"
1251,result = JOptionPane
1252,".showConfirmDialog(null""Description was 'All Files'?"");"
1253,for (UIManager.LookAndFeelInfo info : javax.swing.UIManager
1254,.getInstalledLookAndFeels()) {
1255,"if (""Nimbus"".equals(info.getName())) {"
1256,UIManager.setLookAndFeel(info.getClassName());
1257,SwingUtilities.updateComponentTreeUI(jfc);
1258,break;
1259,jfc.showOpenDialog(null);
1260,result = JOptionPane
1261,".showConfirmDialog(null""Description was 'All Files'?"");"
1262,import java.awt.BorderLayout;
1263,import javax.swing.JFrame;
1264,import javax.swing.JPanel;
1265,import javax.swing.plaf.basic.BasicArrowButton;
1266,import java.awt.BorderLayout;
1267,import javax.swing.JFrame;
1268,import javax.swing.JPanel;
1269,import javax.swing.plaf.basic.BasicArrowButton;
1270,public class Main extends JPanel {
1271,public Main() {
1272,setLayout(new BorderLayout());
1273,JPanel east = new JPanel(new BorderLayout());
1274,add(eastBorderLayout.EAST);
1275,BasicArrowButton north = new BasicArrowButton(BasicArrowButton.NORTH);
1276,east.add(northBorderLayout.NORTH);
1277,BasicArrowButton south = new BasicArrowButton(BasicArrowButton.SOUTH);
1278,east.add(southBorderLayout.SOUTH);
1279,public static void main(String[] args) {
1280,"JFrame frame = new JFrame(""Main"");"
1281,frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
1282,frame.add(new Main());
1283,frame.setSize(200300);
1284,frame.setLocationByPlatform(true);
1285,frame.setVisible(true);
1286,import javax.swing.JFrame;
1287,import javax.swing.JPanel;
1288,import javax.swing.JRootPane;
1289,import javax.swing.SwingUtilities;
1290,import javax.swing.UIManager;
1291,import javax.swing.plaf.ColorUIResource;
1292,import javax.swing.plaf.metal.DefaultMetalTheme;
1293,import javax.swing.plaf.metal.MetalLookAndFeel;
1294,import javax.swing.JFrame;
1295,import javax.swing.JPanel;
1296,import javax.swing.JRootPane;
1297,import javax.swing.SwingUtilities;
1298,import javax.swing.UIManager;
1299,import javax.swing.plaf.ColorUIResource;
1300,import javax.swing.plaf.metal.DefaultMetalTheme;
1301,import javax.swing.plaf.metal.MetalLookAndFeel;
1302,public class Main {
1303,public static void main_helper(String args[]) {
1304,JFrame f = new JFrame();
1305,f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
1306,f.setSize(300300);
1307,f.setUndecorated(true);
1308,f.getRootPane().setWindowDecorationStyle(JRootPane.FRAME);
1309,JPanel panel = new JPanel();
1310,panel.setBackground(java.awt.Color.white);
1311,f.setContentPane(panel);
1312,MetalLookAndFeel.setCurrentTheme(new MyDefaultMetalTheme());
1313,try {
1314,UIManager.setLookAndFeel(new MetalLookAndFeel());
1315,} catch (Exception e) {
1316,e.printStackTrace();
1317,SwingUtilities.updateComponentTreeUI(f);
1318,f.setVisible(true);
1319,public static void main(final String args[]) {
1320,main_helper(args);
1321,class MyDefaultMetalTheme extends DefaultMetalTheme {
1322,public ColorUIResource getWindowTitleInactiveBackground() {
1323,return new ColorUIResource(java.awt.Color.orange);
1324,public ColorUIResource getWindowTitleBackground() {
1325,return new ColorUIResource(java.awt.Color.orange);
1326,public ColorUIResource getPrimaryControlHighlight() {
1327,return new ColorUIResource(java.awt.Color.orange);
1328,public ColorUIResource getPrimaryControlDarkShadow() {
1329,return new ColorUIResource(java.awt.Color.orange);
1330,public ColorUIResource getPrimaryControl() {
1331,return new ColorUIResource(java.awt.Color.orange);
1332,public ColorUIResource getControlHighlight() {
1333,return new ColorUIResource(java.awt.Color.orange);
1334,public ColorUIResource getControlDarkShadow() {
1335,return new ColorUIResource(java.awt.Color.orange);
1336,public ColorUIResource getControl() {
1337,return new ColorUIResource(java.awt.Color.orange);
1338,public class TextIO {
1339,public static void put(int x)     { put(x0); }
1340,public static void put(long x)    { put(x0); }
1341,public static void put(double x)  { put(x0); }
1342,public static void put(char x)    { put(x0); }
1343,public static void put(boolean x) { put(x0); }
1344,public static void put(String x)  { put(x0); }
1345,public static void putln(int x)      { put(x0); newLine(); }
1346,public static void putln(long x)     { put(x0); newLine(); }
1347,public static void putln(double x)   { put(x0); newLine(); }
1348,public static void putln(char x)     { put(x0); newLine(); }
1349,public static void putln(boolean x)  { put(x0); newLine(); }
1350,public static void putln(String x)   { put(x0); newLine(); }
1351,public static void putln(int xint w)     { put(xw); newLine(); }
1352,public static void putln(long xint w)    { put(xw); newLine(); }
1353,public static void putln(double xint w)  { put(xw); newLine(); }
1354,public static void putln(char xint w)    { put(xw); newLine(); }
1355,public static void putln(boolean xint w) { put(xw); newLine(); }
1356,public static void putln(String xint w)  { put(xw); newLine(); }
1357,public static void putln() { newLine(); }
1358,public static void put(int xint w)     { dumpString(String.valueOf(x)w); }
1359,public static void put(long xint w)    { dumpString(String.valueOf(x)w); }
1360,public static void put(double xint w)  { dumpString(realToString(x)w); }
1361,public static void put(char xint w)    { dumpString(String.valueOf(x)w); }
1362,public static void put(boolean xint w) { dumpString(String.valueOf(x)w); }
1363,public static void put(String xint w)  { dumpString(xw); }
1364,public static byte getlnByte()       { byte x=getByte();       emptyBuffer();  return x; }
1365,public static short getlnShort()     { short x=getShort();     emptyBuffer();  return x; }
1366,public static int getlnInt()         { int x=getInt();         emptyBuffer();  return x; }
1367,public static long getlnLong()       { long x=getLong();       emptyBuffer();  return x; }
1368,public static float getlnFloat()     { float x=getFloat();     emptyBuffer();  return x; }
1369,public static double getlnDouble()   { double x=getDouble();   emptyBuffer();  return x; }
1370,public static char getlnChar()       { char x=getChar();       emptyBuffer();  return x; }
1371,public static boolean getlnBoolean() { boolean x=getBoolean(); emptyBuffer();  return x; }
1372,public static String getlnWord()     { String x=getWord();     emptyBuffer();  return x; }
1373,public static String getlnString()   { return getln(); }
1374,public static String getln() {
1375,StringBuffer s = new StringBuffer(100);
1376,char ch = readChar();
1377,while (ch != '\n') {
1378,s.append(ch);
1379,ch = readChar();
1380,return s.toString();
1381,public static byte getByte()   { return (byte)readInteger(-128L127L); }
1382,public static short getShort() { return (short)readInteger(-32768L32767L); }
1383,public static int getInt()     { return (int)readInteger((long)Integer.MIN_VALUE(long)Integer.MAX_VALUE); }
1384,public static long getLong()   { return readInteger(Long.MIN_VALUELong.MAX_VALUE); }
1385,public static char getAnyChar(){ return readChar(); }
1386,public static char peek()      { return lookChar(); }
1387,public static char getChar() {
1388,char ch = lookChar();
1389,while (ch == ' ' || ch == '\n') {
1390,readChar();
1391,if (ch == '\n')
1392,"dumpString(""? ""0);"
1393,ch = lookChar();
1394,return readChar();
1395,public static float getFloat() {
1396,float x = 0.0F;
1397,while (true) {
1398,String str = readRealString();
1399,"if (str.equals("""")) {"
1400,"errorMessage(""Illegal floating point input."""
1401,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
1402,else {
1403,Float f = null;
1404,try { f = Float.valueOf(str); }
1405,catch (NumberFormatException e) {
1406,"errorMessage(""Illegal floating point input."""
1407,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
1408,continue;
1409,if (f.isInfinite()) {
1410,"errorMessage(""Floating point input outside of legal range."""
1411,"""Real number in the range "" + Float.MIN_VALUE + "" to "" + Float.MAX_VALUE);"
1412,continue;
1413,x = f.floatValue();
1414,break;
1415,return x;
1416,public static double getDouble() {
1417,double x = 0.0;
1418,while (true) {
1419,String str = readRealString();
1420,"if (str.equals("""")) {"
1421,"errorMessage(""Illegal floating point input"""
1422,"""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
1423,else {
1424,Double f = null;
1425,try { f = Double.valueOf(str); }
1426,catch (NumberFormatException e) {
1427,"errorMessage(""Illegal floating point input"""
1428,"""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
1429,continue;
1430,if (f.isInfinite()) {
1431,"errorMessage(""Floating point input outside of legal range.""""Real number in the range "" + Double.MIN_VALUE + "" to "" + Double.MAX_VALUE);"
1432,continue;
1433,x = f.doubleValue();
1434,break;
1435,return x;
1436,public static String getWord() {
1437,char ch = lookChar();
1438,while (ch == ' ' || ch == '\n') {
1439,readChar();
1440,if (ch == '\n')
1441,"dumpString(""? ""0);"
1442,ch = lookChar();
1443,StringBuffer str = new StringBuffer(50);
1444,while (ch != ' ' && ch != '\n') {
1445,str.append(readChar());
1446,ch = lookChar();
1447,return str.toString();
1448,public static boolean getBoolean() {
1449,boolean ans = false;
1450,while (true) {
1451,String s = getWord();
1452,"if ( s.equalsIgnoreCase(""true"") || s.equalsIgnoreCase(""t"") || s.equalsIgnoreCase(""yes"")  || s.equalsIgnoreCase(""y"") || s.equals(""1"") ) {"
1453,ans = true;
1454,break;
1455,"else if ( s.equalsIgnoreCase(""false"") || s.equalsIgnoreCase(""f"") || s.equalsIgnoreCase(""no"")  || s.equalsIgnoreCase(""n"") || s.equals(""0"") ) {"
1456,ans = false;
1457,break;
1458,else
1459,"errorMessage(""Illegal boolean input value.""""one of:  truefalsetfyesnoyn0or 1"");"
1460,return ans;
1461,private static InputStream in = System.in;
1462,private static PrintStream out = System.out;
1463,private static String buffer = null;
1464,private static int pos = 0;
1465,private static String readRealString() {
1466,StringBuffer s=new StringBuffer(50);
1467,char ch=lookChar();
1468,while (ch == ' ' || ch == '\n') {
1469,readChar();
1470,if (ch == '\n')
1471,"dumpString(""? ""0);"
1472,ch = lookChar();
1473,if (ch == '-' || ch == '+') {
1474,s.append(readChar());
1475,ch = lookChar();
1476,while (ch == ' ') {
1477,readChar();
1478,ch = lookChar();
1479,while (ch >= '0' && ch <= '9') {
1480,s.append(readChar());
1481,ch = lookChar();
1482,if (ch == '.') {
1483,s.append(readChar());
1484,ch = lookChar();
1485,while (ch >= '0' && ch <= '9') {
1486,s.append(readChar());
1487,ch = lookChar();
1488,if (ch == 'E' || ch == 'e') {
1489,s.append(readChar());
1490,ch = lookChar();
1491,if (ch == '-' || ch == '+') {
1492,s.append(readChar());
1493,ch = lookChar();
1494,while (ch >= '0' && ch <= '9') {
1495,s.append(readChar());
1496,ch = lookChar();
1497,return s.toString();
1498,private static long readInteger(long minlong max) {
1499,long x=0;
1500,while (true) {
1501,StringBuffer s=new StringBuffer(34);
1502,char ch=lookChar();
1503,while (ch == ' ' || ch == '\n') {
1504,readChar();
1505,if (ch == '\n');
1506,"dumpString(""? ""0);"
1507,ch = lookChar();
1508,if (ch == '-' || ch == '+') {
1509,s.append(readChar());
1510,ch = lookChar();
1511,while (ch == ' ') {
1512,readChar();
1513,ch = lookChar();
1514,while (ch >= '0' && ch <= '9') {
1515,s.append(readChar());
1516,ch = lookChar();
1517,"if (s.equals("""")){"
1518,"errorMessage(""Illegal integer input."""
1519,"""Integer in the range "" + min + "" to "" + max);"
1520,else {
1521,String str = s.toString();
1522,try {
1523,x = Long.parseLong(str);
1524,catch (NumberFormatException e) {
1525,"errorMessage(""Illegal integer input."""
1526,"""Integer in the range "" + min + "" to "" + max);"
1527,continue;
1528,if (x < min || x > max) {
1529,"errorMessage(""Integer input outside of legal range."""
1530,"""Integer in the range "" + min + "" to "" + max);"
1531,continue;
1532,break;
1533,return x;
1534,private static String realToString(double x) {
1535,if (Double.isNaN(x))
1536,"return ""undefined"";"
1537,if (Double.isInfinite(x))
1538,if (x < 0)
1539,"return ""-INF"";"
1540,else
1541,"return ""INF"";"
1542,if (Math.abs(x) <= 5000000000.0 && Math.rint(x) == x)
1543,return String.valueOf( (long)x );
1544,String s = String.valueOf(x);
1545,if (s.length() <= 10)
1546,return s;
1547,boolean neg = false;
1548,if (x < 0) {
1549,neg = true;
1550,x = -x;
1551,s = String.valueOf(x);
1552,if (x >= 0.00005 && x <= 50000000 && (s.indexOf('E') == -1 && s.indexOf('e') == -1)) {
1553,s = round(s10);
1554,s = trimZeros(s);
1555,else if (x > 1) {
1556,long power = (long)Math.floor(Math.log(x)/Math.log(10));
1557,"String exp = ""E"" + power;"
1558,int numlength = 10 - exp.length();
1559,x = x / Math.pow(10power);
1560,s = String.valueOf(x);
1561,s = round(snumlength);
1562,s = trimZeros(s);
1563,s += exp;
1564,else {
1565,long power = (long)Math.ceil(-Math.log(x)/Math.log(10));
1566,"String exp = ""E-"" + power;"
1567,int numlength = 10 - exp.length();
1568,x = x * Math.pow(10power);
1569,s = String.valueOf(x);
1570,s = round(snumlength);
1571,s = trimZeros(s);
1572,s += exp;
1573,if (neg)
1574,"return ""-"" + s;"
1575,else
1576,return s;
1577,private static String trimZeros(String num) {
1578,if (num.indexOf('.') >= 0 && num.charAt(num.length() - 1) == '0') {
1579,int i = num.length() - 1;
1580,while (num.charAt(i) == '0')
1581,i--;
1582,if (num.charAt(i) == '.')
1583,num = num.substring(0i);
1584,else
1585,num = num.substring(0i+1);
1586,return num;
1587,private static String round(String numint length) {
1588,if (num.indexOf('.') < 0)
1589,return num;
1590,if (num.length() <= length)
1591,return num;
1592,if (num.charAt(length) >= '5' && num.charAt(length) != '.') {
1593,char[] temp = new char[length+1];
1594,int ct = length;
1595,boolean rounding = true;
1596,for (int i = length-1; i >= 0; i--) {
1597,temp[ct] = num.charAt(i);
1598,if (rounding && temp[ct] != '.') {
1599,if (temp[ct] < '9') {
1600,temp[ct]++;
1601,rounding = false;
1602,else
1603,temp[ct] = '0';
1604,ct--;
1605,if (rounding) {
1606,temp[ct] = '1';
1607,ct--;
1608,return new String(tempct+1length-ct);
1609,else
1610,return num.substring(0length);
1611,private static void dumpString(String strint w) {
1612,for (int i=str.length(); i<w; i++)
1613,out.print(' ');
1614,for (int i=0; i<str.length(); i++)
1615,if ((int)str.charAt(i) >= 0x20 && (int)str.charAt(i) != 0x7F)
1616,out.print(str.charAt(i));
1617,else if (str.charAt(i) == '\n' || str.charAt(i) == '\r')
1618,newLine();
1619,private static void errorMessage(String messageString expecting) {
1620,newLine();
1621,"dumpString(""  *** Error in input: "" + message + ""\n""0);"
1622,"dumpString(""  *** Expecting: "" + expecting + ""\n""0);"
1623,"dumpString(""  *** Discarding Input: ""0);"
1624,if (lookChar() == '\n')
1625,"dumpString(""(end-of-line)\n\n""0);"
1626,else {
1627,while (lookChar() != '\n')
1628,out.print(readChar());
1629,"dumpString(""\n\n""0);"
1630,"dumpString(""Please re-enter: ""0);"
1631,readChar();
1632,private static char lookChar() {
1633,if (buffer == null || pos > buffer.length())
1634,fillBuffer();
1635,if (pos == buffer.length())
1636,return '\n';
1637,return buffer.charAt(pos);
1638,private static char readChar() {
1639,char ch = lookChar();
1640,pos++;
1641,return ch;
1642,private static void newLine() {
1643,out.println();
1644,out.flush();
1645,private static boolean possibleLinefeedPending = false;
1646,private static void fillBuffer() {
1647,StringBuffer b = new StringBuffer();
1648,out.flush();
1649,try {
1650,int ch = in.read();
1651,if (ch == '\n' && possibleLinefeedPending)
1652,ch = in.read();
1653,possibleLinefeedPending = false;
1654,while (ch != -1 && ch != '\n' && ch != '\r') {
1655,b.append((char)ch);
1656,ch = in.read();
1657,possibleLinefeedPending = (ch == '\r');
1658,if (ch == -1) {
1659,"System.out.println(""\n*** Found an end-of-file while trying to read from standard input!"");"
1660,"System.out.println(""*** Maybe your Java system doesn't implement standard input?"");"
1661,"System.out.println(""*** Program will be terminated.\n"");"
1662,"throw new RuntimeException(""End-of-file on standard input."");"
1663,catch (IOException e) {
1664,"System.out.println(""Unexpected system error on input."");"
1665,"System.out.println(""Terminating program."");"
1666,System.exit(1);
1667,buffer = b.toString();
1668,pos = 0;
1669,private static void emptyBuffer() {
1670,buffer = null;
1671,package Maths;
1673,public class Combinations {
1674,public static void main(String[] args) {
1675,assert combinations(11) == 1;
1676,assert combinations(105) == 252;
1677,assert combinations(63) == 20;
1678,assert combinations(205) == 15504;
1682,public static long factorial(int n) {
1683,if (n < 0) {
1684,"throw new IllegalArgumentException(""number is negative"");"
1685,return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
1690,public static long combinations(int nint k) {
1691,return factorial(n) / (factorial(k) * factorial(n - k));
1692,package com.maths;
1696,public class Convolution {
1702,public static double[] convolution(double[] Adouble[] B) {
1703,double[] convolved = new double[A.length + B.length - 1];
1704,The discrete convolution of two signals A and B is defined as:
1705,A.length
1706,C[i] = Î£ (A[k]*B[i-k])
1707,It's obvious that:  0 <= k <= A.length0 <= i <= A.length + B.length - 2  and  0 <= i-k <= B.length - 1
1708,From the last inequality we get that:  i - B.length + 1 <= k <= i and thus we get the conditions below.
1709,for (int i = 0; i < convolved.length; i++) {
1710,convolved[i] = 0;
1711,int k = Math.max(i - B.length + 10);
1712,while (k < i + 1 && k < A.length) {
1713,convolved[i] += A[k] * B[i - k];
1714,k++;
1715,return convolved;
1716,package com.maths;
1717,import java.util.ArrayList;
1721,public class ConvolutionFFT {
1725,private static void padding(ArrayList<FFT.Complex> xint newSize) {
1726,if (x.size() < newSize) {
1727,int diff = newSize - x.size();
1728,for (int i = 0; i < diff; i++) x.add(new FFT.Complex());
1739,public static ArrayList<FFT.Complex> convolutionFFT(
1740,ArrayList<FFT.Complex> aArrayList<FFT.Complex> b) {
1741,int convolvedSize = a.size() + b.size() - 1;
1742,padding(aconvolvedSize);
1743,padding(bconvolvedSize);
1745,FFT.fft(afalse);
1746,FFT.fft(bfalse);
1747,ArrayList<FFT.Complex> convolved = new ArrayList<>();
1748,for (int i = 0; i < a.size(); i++) convolved.add(a.get(i).multiply(b.get(i)));
1749,FFT.fft(convolvedtrue);
1750,convolved
1751,.subList(convolvedSizeconvolved.size())
1752,.clear();
1754,return convolved;
1755,package Maths;
1756,import java.util.ArrayList;
1757,import java.util.function.BiFunction;
1766,public class EulerMethod {
1768,public static void main(String[] args) {
1769,"System.out.println(""example 1:"");"
1770,BiFunction<DoubleDoubleDouble> exampleEquation1 = (xy) -> x;
1771,ArrayList<double[]> points1 = eulerFull(040.10exampleEquation1);
1772,assert points1.get(points1.size() - 1)[1] == 7.800000000000003;
1773,points1.forEach(
1774,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1776,"System.out.println(""\n\nexample 2:"");"
1777,BiFunction<DoubleDoubleDouble> exampleEquation2 = (xy) -> y;
1778,ArrayList<double[]> points2 = eulerFull(040.11exampleEquation2);
1779,assert points2.get(points2.size() - 1)[1] == 45.25925556817596;
1780,points2.forEach(
1781,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1783,"System.out.println(""\n\nexample 3:"");"
1784,BiFunction<DoubleDoubleDouble> exampleEquation3 = (xy) -> x + y + x * y;
1785,ArrayList<double[]> points3 = eulerFull(00.10.0251exampleEquation3);
1786,assert points3.get(points3.size() - 1)[1] == 1.1116729841674804;
1787,points3.forEach(
1788,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1795,public static double eulerStep(
1796,double xCurrent
1797,double stepSize
1798,double yCurrent
1799,BiFunction<DoubleDoubleDouble> differentialEquation) {
1800,if (stepSize <= 0) {
1801,"throw new IllegalArgumentException(""stepSize should be greater than zero"");"
1802,double yNext = yCurrent + stepSize * differentialEquation.apply(xCurrentyCurrent);
1803,return yNext;
1812,public static ArrayList<double[]> eulerFull(
1813,double xStart
1814,double xEnd
1815,double stepSize
1816,double yStart
1817,BiFunction<DoubleDoubleDouble> differentialEquation) {
1818,if (xStart >= xEnd) {
1819,"throw new IllegalArgumentException(""xEnd should be greater than xStart"");"
1820,if (stepSize <= 0) {
1821,"throw new IllegalArgumentException(""stepSize should be greater than zero"");"
1822,ArrayList<double[]> points = new ArrayList<double[]>();
1823,double[] firstPoint = {xStartyStart};
1824,points.add(firstPoint);
1825,double yCurrent = yStart;
1826,double xCurrent = xStart;
1827,while (xCurrent < xEnd) {
1829,yCurrent = eulerStep(xCurrentstepSizeyCurrentdifferentialEquation);
1830,xCurrent += stepSize;
1831,double[] point = {xCurrentyCurrent};
1832,points.add(point);
1833,return points;
1834,package Maths;
1835,import java.util.ArrayList;
1836,import java.util.function.BiFunction;
1845,public class EulerMethod {
1847,public static void main(String[] args) {
1848,"System.out.println(""example 1:"");"
1849,BiFunction<DoubleDoubleDouble> exampleEquation1 = (xy) -> x;
1850,ArrayList<double[]> points1 = eulerFull(040.10exampleEquation1);
1851,assert points1.get(points1.size() - 1)[1] == 7.800000000000003;
1852,points1.forEach(
1853,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1855,"System.out.println(""\n\nexample 2:"");"
1856,BiFunction<DoubleDoubleDouble> exampleEquation2 = (xy) -> y;
1857,ArrayList<double[]> points2 = eulerFull(040.11exampleEquation2);
1858,assert points2.get(points2.size() - 1)[1] == 45.25925556817596;
1859,points2.forEach(
1860,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1862,"System.out.println(""\n\nexample 3:"");"
1863,BiFunction<DoubleDoubleDouble> exampleEquation3 = (xy) -> x + y + x * y;
1864,ArrayList<double[]> points3 = eulerFull(00.10.0251exampleEquation3);
1865,assert points3.get(points3.size() - 1)[1] == 1.1116729841674804;
1866,points3.forEach(
1867,"point -> System.out.println(String.format(""x: %1$f; y: %2$f""point[0]point[1])));"
1874,public static double eulerStep(
1875,double xCurrent
1876,double stepSize
1877,double yCurrent
1878,BiFunction<DoubleDoubleDouble> differentialEquation) {
1879,if (stepSize <= 0) {
1880,"throw new IllegalArgumentException(""stepSize should be greater than zero"");"
1881,double yNext = yCurrent + stepSize * differentialEquation.apply(xCurrentyCurrent);
1882,return yNext;
1891,public static ArrayList<double[]> eulerFull(
1892,double xStart
1893,double xEnd
1894,double stepSize
1895,double yStart
1896,BiFunction<DoubleDoubleDouble> differentialEquation) {
1897,if (xStart >= xEnd) {
1898,"throw new IllegalArgumentException(""xEnd should be greater than xStart"");"
1899,if (stepSize <= 0) {
1900,"throw new IllegalArgumentException(""stepSize should be greater than zero"");"
1901,ArrayList<double[]> points = new ArrayList<double[]>();
1902,double[] firstPoint = {xStartyStart};
1903,points.add(firstPoint);
1904,double yCurrent = yStart;
1905,double xCurrent = xStart;
1906,while (xCurrent < xEnd) {
1908,yCurrent = eulerStep(xCurrentstepSizeyCurrentdifferentialEquation);
1909,xCurrent += stepSize;
1910,double[] point = {xCurrentyCurrent};
1911,points.add(point);
1912,return points;
1913,package Maths;
1914,public class Factorial {
1916,public static void main(String[] args) {
1917,assert factorial(0) == 1;
1918,assert factorial(1) == 1;
1919,assert factorial(5) == 120;
1920,assert factorial(10) == 3628800;
1924,public static long factorial(int n) {
1925,if (n < 0) {
1926,"throw new IllegalArgumentException(""number is negative"");"
1927,long factorial = 1;
1928,for (int i = 1; i <= n; factorial *= i++i)
1929,return factorial;
1930,package Maths;
1931,public class FactorialRecursion {
1933,public static void main(String[] args) {
1934,assert factorial(0) == 1;
1935,assert factorial(1) == 1;
1936,assert factorial(2) == 2;
1937,assert factorial(3) == 6;
1938,assert factorial(5) == 120;
1942,public static long factorial(int n) {
1943,if (n < 0) {
1944,"throw new IllegalArgumentException(""number is negative"");"
1945,return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
1946,package com.maths;
1947,import java.util.ArrayList;
1948,import java.util.Collections;
1953,public class FFT {
1956,static class Complex {
1957,private double realimg;
1959,public Complex() {
1960,real = 0;
1961,img = 0;
1965,public Complex(double rdouble i) {
1966,real = r;
1967,img = i;
1970,public double getReal() {
1971,return real;
1974,public double getImaginary() {
1975,return img;
1979,public Complex add(Complex z) {
1980,Complex temp = new Complex();
1981,temp.real = this.real + z.real;
1982,temp.img = this.img + z.img;
1983,return temp;
1987,public Complex subtract(Complex z) {
1988,Complex temp = new Complex();
1989,temp.real = this.real - z.real;
1990,temp.img = this.img - z.img;
1991,return temp;
1995,public Complex multiply(Complex z) {
1996,Complex temp = new Complex();
1997,temp.real = this.real * z.real - this.img * z.img;
1998,temp.img = this.real * z.img + this.img * z.real;
1999,return temp;
2003,public Complex multiply(double n) {
2004,Complex temp = new Complex();
2005,temp.real = this.real * n;
2006,temp.img = this.img * n;
2007,return temp;
2010,public Complex conjugate() {
2011,Complex temp = new Complex();
2012,temp.real = this.real;
2013,temp.img = -this.img;
2014,return temp;
2017,public double abs() {
2018,return Math.hypot(this.realthis.img);
2022,public Complex divide(Complex z) {
2023,Complex temp = new Complex();
2024,temp.real = (this.real * z.real + this.img * z.img) / (z.abs() * z.abs());
2025,temp.img = (this.img * z.real - this.real * z.img) / (z.abs() * z.abs());
2026,return temp;
2030,public Complex divide(double n) {
2031,Complex temp = new Complex();
2032,temp.real = this.real / n;
2033,temp.img = this.img / n;
2034,return temp;
2044,public static void fft(ArrayList<Complex> xboolean inverse) {
2046,paddingPowerOfTwo(x);
2047,int N = x.size();
2049,int log2N = 0;
2050,while ((1 << log2N) < N) log2N++;
2052,int reverse;
2053,for (int i = 0; i < N; i++) {
2054,reverse = reverseBits(ilog2N);
2055,if (i < reverse) Collections.swap(xireverse);
2056,int direction = inverse ? -1 : 1;
2058,for (int len = 2; len <= N; len *= 2) {
2059,double angle = -2 * Math.PI / len * direction;
2060,Complex wlen = new Complex(Math.cos(angle)Math.sin(angle));
2061,for (int i = 0; i < N; i += len) {
2062,Complex w = new Complex(10);
2063,for (int j = 0; j < len / 2; j++) {
2064,Complex u = x.get(i + j);
2065,Complex v = w.multiply(x.get(i + j + len / 2));
2066,x.set(i + ju.add(v));
2067,x.set(i + j + len / 2u.subtract(v));
2068,w = w.multiply(wlen);
2070,if (inverse) {
2071,for (int i = 0; i < x.size(); i++) {
2072,Complex z = x.get(i);
2073,x.set(iz.divide(N));
2081,private static int reverseBits(int numint log2N) {
2082,int reversed = 0;
2083,for (int i = 0; i < log2N; i++) {
2084,if ((num & (1 << i)) != 0) reversed |= 1 << (log2N - 1 - i);
2085,return reversed;
2089,private static void paddingPowerOfTwo(ArrayList<Complex> x) {
2090,int n = 1;
2091,int oldSize = x.size();
2092,while (n < oldSize) n *= 2;
2093,for (int i = 0; i < n - oldSize; i++) x.add(new Complex());
2094,package com.maths;
2095,import java.util.ArrayList;
2096,import java.util.Collections;
2101,public class FFT {
2104,static class Complex {
2105,private double realimg;
2107,public Complex() {
2108,real = 0;
2109,img = 0;
2113,public Complex(double rdouble i) {
2114,real = r;
2115,img = i;
2118,public double getReal() {
2119,return real;
2122,public double getImaginary() {
2123,return img;
2127,public Complex add(Complex z) {
2128,Complex temp = new Complex();
2129,temp.real = this.real + z.real;
2130,temp.img = this.img + z.img;
2131,return temp;
2135,public Complex subtract(Complex z) {
2136,Complex temp = new Complex();
2137,temp.real = this.real - z.real;
2138,temp.img = this.img - z.img;
2139,return temp;
2143,public Complex multiply(Complex z) {
2144,Complex temp = new Complex();
2145,temp.real = this.real * z.real - this.img * z.img;
2146,temp.img = this.real * z.img + this.img * z.real;
2147,return temp;
2151,public Complex multiply(double n) {
2152,Complex temp = new Complex();
2153,temp.real = this.real * n;
2154,temp.img = this.img * n;
2155,return temp;
2158,public Complex conjugate() {
2159,Complex temp = new Complex();
2160,temp.real = this.real;
2161,temp.img = -this.img;
2162,return temp;
2165,public double abs() {
2166,return Math.hypot(this.realthis.img);
2170,public Complex divide(Complex z) {
2171,Complex temp = new Complex();
2172,temp.real = (this.real * z.real + this.img * z.img) / (z.abs() * z.abs());
2173,temp.img = (this.img * z.real - this.real * z.img) / (z.abs() * z.abs());
2174,return temp;
2178,public Complex divide(double n) {
2179,Complex temp = new Complex();
2180,temp.real = this.real / n;
2181,temp.img = this.img / n;
2182,return temp;
2192,public static void fft(ArrayList<Complex> xboolean inverse) {
2194,paddingPowerOfTwo(x);
2195,int N = x.size();
2197,int log2N = 0;
2198,while ((1 << log2N) < N) log2N++;
2200,int reverse;
2201,for (int i = 0; i < N; i++) {
2202,reverse = reverseBits(ilog2N);
2203,if (i < reverse) Collections.swap(xireverse);
2204,int direction = inverse ? -1 : 1;
2206,for (int len = 2; len <= N; len *= 2) {
2207,double angle = -2 * Math.PI / len * direction;
2208,Complex wlen = new Complex(Math.cos(angle)Math.sin(angle));
2209,for (int i = 0; i < N; i += len) {
2210,Complex w = new Complex(10);
2211,for (int j = 0; j < len / 2; j++) {
2212,Complex u = x.get(i + j);
2213,Complex v = w.multiply(x.get(i + j + len / 2));
2214,x.set(i + ju.add(v));
2215,x.set(i + j + len / 2u.subtract(v));
2216,w = w.multiply(wlen);
2218,if (inverse) {
2219,for (int i = 0; i < x.size(); i++) {
2220,Complex z = x.get(i);
2221,x.set(iz.divide(N));
2229,private static int reverseBits(int numint log2N) {
2230,int reversed = 0;
2231,for (int i = 0; i < log2N; i++) {
2232,if ((num & (1 << i)) != 0) reversed |= 1 << (log2N - 1 - i);
2233,return reversed;
2237,private static void paddingPowerOfTwo(ArrayList<Complex> x) {
2238,int n = 1;
2239,int oldSize = x.size();
2240,while (n < oldSize) n *= 2;
2241,for (int i = 0; i < n - oldSize; i++) x.add(new Complex());
2242,package com.maths;
2243,import java.util.ArrayList;
2248,public class FFTBluestein {
2254,public static void fftBluestein(ArrayList<FFT.Complex> xboolean inverse) {
2255,int N = x.size();
2256,int bnSize = 2 * N - 1;
2257,int direction = inverse ? -1 : 1;
2258,ArrayList<FFT.Complex> an = new ArrayList<>();
2259,ArrayList<FFT.Complex> bn = new ArrayList<>();
2261,for (int i = 0; i < bnSize; i++) bn.add(new FFT.Complex());
2262,for (int i = 0; i < N; i++) {
2263,double angle = (i - N + 1) * (i - N + 1) * Math.PI / N * direction;
2264,bn.set(inew FFT.Complex(Math.cos(angle)Math.sin(angle)));
2265,bn.set(bnSize - i - 1new FFT.Complex(Math.cos(angle)Math.sin(angle)));
2267,for (int i = 0; i < N; i++) {
2268,double angle = -i * i * Math.PI / N * direction;
2269,an.add(x.get(i).multiply(new FFT.Complex(Math.cos(angle)Math.sin(angle))));
2270,ArrayList<FFT.Complex> convolution = ConvolutionFFT.convolutionFFT(anbn);
2272,for (int i = 0; i < N; i++) {
2273,double angle = -1 * i * i * Math.PI / N * direction;
2274,FFT.Complex bk = new FFT.Complex(Math.cos(angle)Math.sin(angle));
2275,x.set(ibk.multiply(convolution.get(i + N - 1)));
2277,if (inverse) {
2278,for (int i = 0; i < N; i++) {
2279,FFT.Complex z = x.get(i);
2280,x.set(iz.divide(N));
2281,package Maths;
2283,public class FibonacciNumber {
2284,public static void main(String[] args) {
2285,assert isFibonacciNumber(1);
2286,assert isFibonacciNumber(2);
2287,assert isFibonacciNumber(21);
2288,assert !isFibonacciNumber(9);
2289,assert !isFibonacciNumber(10);
2293,public static boolean isPerfectSquare(int number) {
2294,int sqrt = (int) Math.sqrt(number);
2295,return sqrt * sqrt == number;
2301,public static boolean isFibonacciNumber(int number) {
2302,return isPerfectSquare(5 * number * number + 4) || isPerfectSquare(5 * number * number - 4);
2303,package Maths;
2304,import java.util.Arrays;
2305,import java.util.Random;
2306,public class FindMax {
2308,public static void main(String[] args) {
2309,Random random = new Random();
2311,int size = random.nextInt(100) + 1;
2312,int[] array = new int[size];
2314,for (int i = 0; i < size; i++) {
2315,array[i] = random.nextInt() % 100;
2316,assert Arrays.stream(array).max().getAsInt() == findMax(array);
2320,public static int findMax(int[] array) {
2321,int max = array[0];
2322,for (int i = 1; i < array.length; ++i) {
2323,if (array[i] > max) {
2324,max = array[i];
2325,return max;
2326,package Maths;
2327,import java.util.Arrays;
2328,import java.util.Random;
2329,public class FindMaxRecursion {
2330,public static void main(String[] args) {
2331,Random rand = new Random();
2333,int size = rand.nextInt(100) + 1;
2334,int[] array = new int[size];
2336,for (int i = 0; i < size; i++) {
2337,array[i] = rand.nextInt() % 100;
2338,assert max(arrayarray.length) == Arrays.stream(array).max().getAsInt();
2339,assert max(array0array.length - 1) == Arrays.stream(array).max().getAsInt();
2345,public static int max(int[] arrayint lowint high) {
2346,if (low == high) {
2347,return array[low];
2348,int mid = (low + high) >>> 1;
2349,int leftMax = max(arraylowmid);
2350,int rightMax = max(arraymid + 1high);
2351,return Math.max(leftMaxrightMax);
2356,public static int max(int[] arrayint len) {
2357,return len == 1 ? array[0] : Math.max(max(arraylen - 1)array[len - 1]);
2358,package Maths;
2359,import java.util.Arrays;
2360,import java.util.Random;
2361,public class FindMin {
2363,public static void main(String[] args) {
2364,Random random = new Random();
2366,int size = random.nextInt(100) + 1;
2367,int[] array = new int[size];
2369,for (int i = 0; i < size; i++) {
2370,array[i] = random.nextInt() % 100;
2371,assert Arrays.stream(array).min().getAsInt() == findMin(array);
2375,public static int findMin(int[] array) {
2376,int min = array[0];
2377,for (int i = 1; i < array.length; ++i) {
2378,if (array[i] < min) {
2379,min = array[i];
2380,return min;
2381,package Maths;
2382,import java.util.Arrays;
2383,import java.util.Random;
2384,public class FindMinRecursion {
2386,public static void main(String[] args) {
2387,Random rand = new Random();
2389,int size = rand.nextInt(100) + 1;
2390,int[] array = new int[size];
2392,for (int i = 0; i < size; i++) {
2393,array[i] = rand.nextInt() % 100;
2394,assert min(array0array.length - 1) == Arrays.stream(array).min().getAsInt();
2395,assert min(arrayarray.length) == Arrays.stream(array).min().getAsInt();
2401,public static int min(int[] arrayint lowint high) {
2402,if (low == high) {
2403,return array[low];
2404,int mid = (low + high) >>> 1;
2405,int leftMin = min(arraylowmid);
2406,int rightMin = min(arraymid + 1high);
2407,return Math.min(leftMinrightMin);
2412,public static int min(int[] arrayint len) {
2413,return len == 1 ? array[0] : Math.min(min(arraylen - 1)array[len - 1]);
2414,package Maths;
2415,import java.util.Random;
2416,public class Floor {
2417,public static void main(String[] args) {
2418,Random random = new Random();
2419,for (int i = 1; i <= 1000; ++i) {
2420,double randomNumber = random.nextDouble();
2421,assert floor(randomNumber) == Math.floor(randomNumber);
2425,public static double floor(double number) {
2426,if (number - (int) number == 0) {
2427,return number;
2428,} else if (number - (int) number > 0) {
2429,return (int) number;
2430,} else {
2431,return (int) number - 1;
2432,package Maths;
2436,public class GCD {
2441,public static int gcd(int num1int num2) {
2442,if (num1 < 0 || num2 < 0) {
2443,throw new ArithmeticException();
2444,if (num1 == 0 || num2 == 0) {
2445,return Math.abs(num1 - num2);
2446,while (num1 % num2 != 0) {
2447,int remainder = num1 % num2;
2448,num1 = num2;
2449,num2 = remainder;
2450,return num2;
2454,public static int gcd(int[] number) {
2455,int result = number[0];
2456,for (int i = 1; i < number.length; i++)
2458,result = gcd(resultnumber[i]);
2459,return result;
2460,public static void main(String[] args) {
2461,int[] myIntArray = {41632};
2463,System.out.println(gcd(myIntArray));
2464,"System.out.printf(""gcd(4024)=%d gcd(2440)=%d%n""gcd(4024)gcd(2440));"
2465,package Maths;
2467,public class GCDRecursion {
2468,public static void main(String[] args) {
2469,System.out.println(gcd(2015)); /* output: 5 */
2470,System.out.println(gcd(108)); /* output: 2 */
2471,System.out.println(gcd(gcd(105)gcd(510))); /* output: 5 */
2476,public static int gcd(int aint b) {
2477,if (a < 0 || b < 0) {
2478,throw new ArithmeticException();
2479,if (a == 0 || b == 0) {
2480,return Math.abs(a - b);
2481,if (a % b == 0) {
2482,return b;
2483,} else {
2484,return gcd(ba % b);
2485,package Maths;
2487,public class LucasSeries {
2488,public static void main(String[] args) {
2489,assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;
2490,assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;
2491,assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;
2492,assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;
2493,assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;
2494,assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;
2495,assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;
2500,public static int lucasSeries(int n) {
2501,return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);
2506,public static int lucasSeriesIteration(int n) {
2507,int previous = 2;
2508,int current = 1;
2509,for (int i = 1; i < n; i++) {
2510,int next = previous + current;
2511,previous = current;
2512,current = next;
2513,return previous;
2514,package Maths;
2515,import java.util.Random;
2516,public class MaxValue {
2518,public static void main(String[] args) {
2519,Random rand = new Random();
2521,for (int i = 1; i <= 100; ++i) {
2523,int a = rand.nextInt(100) - 50;
2524,int b = rand.nextInt(100) - 50;
2525,assert max(ab) == Math.max(ab);
2532,public static int max(int aint b) {
2533,return a >= b ? a : b;
2534,package Maths;
2535,import java.util.Arrays;
2537,public class Median {
2538,public static void main(String[] args) {
2539,assert median(new int[] {0}) == 0;
2540,assert median(new int[] {12}) == 1.5;
2541,assert median(new int[] {4132}) == 2.5;
2542,assert median(new int[] {1336789}) == 6;
2543,assert median(new int[] {12345689}) == 4.5;
2547,public static double median(int[] values) {
2548,Arrays.sort(values);
2549,int length = values.length;
2550,return length % 2 == 0
2551,? (values[length / 2] + values[length / 2 - 1]) / 2.0
2552,: values[length / 2];
2553,package Maths;
2554,import java.util.Random;
2555,public class MinValue {
2557,public static void main(String[] args) {
2558,Random rand = new Random();
2560,for (int i = 1; i <= 100; ++i) {
2562,int a = rand.nextInt(100) - 50;
2563,int b = rand.nextInt(100) - 50;
2564,assert min(ab) == Math.min(ab);
2571,public static int min(int aint b) {
2572,return a <= b ? a : b;
2573,package Maths;
2574,import java.util.ArrayList;
2575,import java.util.Arrays;
2576,import java.util.Collections;
2577,import java.util.HashMap;
2581,public class Mode {
2582,public static void main(String[] args) {
2584,assert (mode(new int[] {})) == null;
2585,assert Arrays.equals(mode(new int[] {5})new int[] {5});
2586,assert Arrays.equals(mode(new int[] {12345})new int[] {12345});
2587,assert Arrays.equals(mode(new int[] {799456778})new int[] {7});
2588,assert Arrays.equals(mode(new int[] {799456779})new int[] {79});
2592,public static int[] mode(int[] numbers) {
2593,if (numbers.length == 0) return null;
2594,HashMap<IntegerInteger> count = new HashMap<>();
2595,for (int num : numbers) {
2596,if (count.containsKey(num)) {
2597,count.put(numcount.get(num) + 1);
2598,} else {
2599,count.put(num1);
2600,int max = Collections.max(count.values());
2601,ArrayList<Integer> modes = new ArrayList<>();
2602,for (int num : count.keySet()) {
2603,if (count.get(num) == max) {
2604,modes.add(num);
2605,return modes.stream().mapToInt(n -> n).toArray();
2606,package Maths;
2608,public class NumberOfDigits {
2609,public static void main(String[] args) {
2610,int[] numbers = {0121231234-12345123456123456712345678123456789};
2611,for (int i = 0; i < numbers.length; ++i) {
2612,assert numberOfDigits(numbers[i]) == i + 1;
2613,assert numberOfDigitsFast(numbers[i]) == i + 1;
2614,assert numberOfDigitsFaster(numbers[i]) == i + 1;
2615,assert numberOfDigitsRecursion(numbers[i]) == i + 1;
2619,private static int numberOfDigits(int number) {
2620,int digits = 0;
2621,do {
2622,digits++;
2623,number /= 10;
2624,} while (number != 0);
2625,return digits;
2629,private static int numberOfDigitsFast(int number) {
2630,return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1);
2634,private static int numberOfDigitsFaster(int number) {
2635,"return number < 0 ? (-number + """").length() : (number + """").length();"
2639,private static int numberOfDigitsRecursion(int number) {
2640,return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10);
2641,package Maths;
2642,public class PalindromeNumber {
2643,public static void main(String[] args) {
2644,assert isPalindrome(12321);
2645,assert !isPalindrome(1234);
2646,assert isPalindrome(1);
2650,public static boolean isPalindrome(int number) {
2651,if (number < 0) {
2652,"throw new IllegalArgumentException(number + """");"
2653,int numberCopy = number;
2654,int reverseNumber = 0;
2655,while (numberCopy != 0) {
2656,int remainder = numberCopy % 10;
2657,reverseNumber = reverseNumber * 10 + remainder;
2658,numberCopy /= 10;
2659,return number == reverseNumber;
2660,package Maths;
2661,public class ParseInteger {
2662,public static void main(String[] args) {
2663,"assert parseInt(""123"") == Integer.parseInt(""123"");"
2664,"assert parseInt(""-123"") == Integer.parseInt(""-123"");"
2665,"assert parseInt(""0123"") == Integer.parseInt(""0123"");"
2666,"assert parseInt(""+123"") == Integer.parseInt(""+123"");"
2671,public static int parseInt(String s) {
2672,if (s == null || s.length() == 0) {
2673,"throw new NumberFormatException(""null"");"
2674,boolean isNegative = s.charAt(0) == '-';
2675,boolean isPositive = s.charAt(0) == '+';
2676,int number = 0;
2677,for (int i = isNegative ? 1 : isPositive ? 1 : 0length = s.length(); i < length; ++i) {
2678,if (!Character.isDigit(s.charAt(i))) {
2679,"throw new NumberFormatException(""s="" + s);"
2680,number = number * 10 + s.charAt(i) - '0';
2681,return isNegative ? -number : number;
2682,package Maths;
2684,public class PerfectCube {
2685,public static void main(String[] args) {
2686,assert !isPerfectCube(-1);
2687,assert isPerfectCube(0);
2688,assert isPerfectCube(1);
2689,assert !isPerfectCube(4);
2690,assert isPerfectCube(8);
2691,assert isPerfectCube(27);
2695,public static boolean isPerfectCube(int number) {
2696,int a = (int) Math.pow(number1.0 / 3);
2697,return a * a * a == number;
2698,package Maths;
2703,public class PerfectNumber {
2704,public static void main(String[] args) {
2705,assert isPerfectNumber(6); /* 1 + 2 + 3 == 6 */
2706,assert !isPerfectNumber(8); /* 1 + 2 + 4 != 8 */
2707,assert isPerfectNumber(28); /* 1 + 2 + 4 + 7 + 14 == 28 */
2711,public static boolean isPerfectNumber(int number) {
2712,int sum = 0; /* sum of its positive divisors */
2713,for (int i = 1; i < number; ++i) {
2714,if (number % i == 0) {
2715,sum += i;
2716,return sum == number;
2717,package Maths;
2719,public class PerfectSquare {
2720,public static void main(String[] args) {
2721,assert !isPerfectSquare(-1);
2722,assert !isPerfectSquare(3);
2723,assert !isPerfectSquare(5);
2724,assert isPerfectSquare(9);
2725,assert isPerfectSquare(100);
2729,public static boolean isPerfectSquare(int number) {
2730,int sqrt = (int) Math.sqrt(number);
2731,return sqrt * sqrt == number;
2732,package Maths;
2733,public class PiNilakantha {
2737,public static void main(String[] args) {
2738,assert calculatePi(0) == 3.0;
2739,assert calculatePi(10) > 3.0;
2740,assert calculatePi(100) < 4.0;
2741,System.out.println(calculatePi(500));
2746,public static double calculatePi(int iterations) {
2747,if (iterations < 0 || iterations > 500) {
2748,"throw new IllegalArgumentException(""Please input Integer Number between 0 and 500"");"
2749,double pi = 3;
2750,int divCounter = 2;
2751,for (int i = 0; i < iterations; i++) {
2752,if (i % 2 == 0) pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
2753,else pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
2754,divCounter += 2;
2755,return pi;
2756,package Maths;
2758,public class Pow {
2759,public static void main(String[] args) {
2760,assert pow(20) == Math.pow(20);
2761,assert pow(02) == Math.pow(02);
2762,assert pow(210) == Math.pow(210);
2763,assert pow(102) == Math.pow(102);
2768,public static long pow(int aint b) {
2769,long result = 1;
2770,for (int i = 1; i <= b; i++) {
2771,result *= a;
2772,return result;
2773,package Maths;
2775,public class PowerOfTwoOrNot {
2776,public static void main(String[] args) {
2777,assert !checkIfPowerOfTwoOrNot(0);
2778,assert checkIfPowerOfTwoOrNot(1);
2779,assert checkIfPowerOfTwoOrNot(8);
2780,assert checkIfPowerOfTwoOrNot(16);
2781,assert checkIfPowerOfTwoOrNot(1024);
2785,public static boolean checkIfPowerOfTwoOrNot(int number) {
2786,return number != 0 && ((number & (number - 1)) == 0);
2787,package Maths;
2788,public class PowRecursion {
2789,public static void main(String[] args) {
2790,assert Double.compare(pow(20)Math.pow(20)) == 0;
2791,assert Double.compare(pow(02)Math.pow(02)) == 0;
2792,assert Double.compare(pow(210)Math.pow(210)) == 0;
2793,assert Double.compare(pow(102)Math.pow(102)) == 0;
2798,public static long pow(int aint b) {
2799,return b == 0 ? 1 : a * pow(ab - 1);
2800,package Maths;
2801,import java.util.Scanner;
2802,public class PrimeCheck {
2803,public static void main(String[] args) {
2804,Scanner scanner = new Scanner(System.in);
2805,"System.out.print(""Enter a number: "");"
2806,int n = scanner.nextInt();
2807,if (isPrime(n)) {
2808,"System.out.println(n + "" is a prime number"");"
2809,} else {
2810,"System.out.println(n + "" is not a prime number"");"
2811,scanner.close();
2816,public static boolean isPrime(int n) {
2817,if (n == 2) {
2818,return true;
2819,if (n < 2 || n % 2 == 0) {
2820,return false;
2821,for (int i = 3limit = (int) Math.sqrt(n); i <= limit; i += 2) {
2822,if (n % i == 0) {
2823,return false;
2824,return true;
2825,package Maths;
2826,import java.util.Scanner;
2827,public class PrimeFactorization {
2828,public static void main(String[] args) {
2829,"System.out.println(""## all prime factors ##"");"
2830,Scanner scanner = new Scanner(System.in);
2831,"System.out.print(""Enter a number: "");"
2832,int n = scanner.nextInt();
2833,"System.out.print((""printing factors of "" + n + "" : ""));"
2834,pfactors(n);
2835,scanner.close();
2836,public static void pfactors(int n) {
2837,while (n % 2 == 0) {
2838,"System.out.print(2 + "" "");"
2839,n /= 2;
2840,for (int i = 3; i <= Math.sqrt(n); i += 2) {
2841,while (n % i == 0) {
2842,"System.out.print(i + "" "");"
2843,n /= i;
2844,if (n > 2) System.out.print(n);
2845,package Maths;
2847,public class PythagoreanTriple {
2848,public static void main(String[] args) {
2849,assert isPythagTriple(345);
2850,assert isPythagTriple(51213);
2851,assert isPythagTriple(6810);
2852,assert !isPythagTriple(102030);
2853,assert !isPythagTriple(68100);
2854,assert !isPythagTriple(-1-11);
2861,public static boolean isPythagTriple(int aint bint c) {
2862,if (a <= 0 || b <= 0 || c <= 0) {
2863,return false;
2864,} else {
2865,return (a * a) + (b * b) == (c * c);
2866,package Maths;
2872,public class SumOfArithmeticSeries {
2873,public static void main(String[] args) {
2875,assert Double.compare(55.0sumOfSeries(1110)) == 0;
2877,assert Double.compare(100.0sumOfSeries(1210)) == 0;
2879,assert Double.compare(460.0sumOfSeries(11010)) == 0;
2881,assert Double.compare(5.5sumOfSeries(0.10.110)) == 0;
2882,assert Double.compare(49600.0sumOfSeries(110100)) == 0;
2888,private static double sumOfSeries(double firstTermdouble commonDiffint numOfTerms) {
2889,return numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff);
2890,package Maths;
2891,public class SumOfDigits {
2892,public static void main(String[] args) {
2893,assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;
2894,assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;
2895,assert sumOfDigits(12345) == 15
2896,&& sumOfDigitsRecursion(12345) == 15
2897,&& sumOfDigitsFast(12345) == 15;
2901,public static int sumOfDigits(int number) {
2902,number = number < 0 ? -number : number; /* calculate abs value */
2903,int sum = 0;
2904,while (number != 0) {
2905,sum += number % 10;
2906,number /= 10;
2907,return sum;
2911,public static int sumOfDigitsRecursion(int number) {
2912,number = number < 0 ? -number : number; /* calculate abs value */
2913,return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);
2917,public static int sumOfDigitsFast(int number) {
2918,number = number < 0 ? -number : number; /* calculate abs value */
2919,"char[] digits = (number + """").toCharArray();"
2920,int sum = 0;
2921,for (int i = 0; i < digits.length; ++i) {
2922,sum += digits[i] - '0';
2923,return sum;
2924,package Maths;
2925,import java.util.ArrayList;
2926,import java.util.Collections;
2934,public class VampireNumber {
2935,public static void main(String[] args) {
2936,test(101000);
2937,static void test(int startValueint stopValue) {
2938,int countofRes = 1;
2939,StringBuilder res = new StringBuilder();
2940,for (int i = startValue; i <= stopValue; i++) {
2941,for (int j = i; j <= stopValue; j++) {
2943,if (isVampireNumber(ijtrue)) {
2944,countofRes++;
2945,"res.append("""" + countofRes + "": = ( "" + i + """" + j + "" = "" + i * j + "")"" + ""\n"");"
2946,System.out.println(res);
2947,static boolean isVampireNumber(int aint bboolean noPseudoVamireNumbers) {
2951,if (noPseudoVamireNumbers) {
2952,if (a * 10 <= b || b * 10 <= a) {
2953,return false;
2954,String mulDigits = splitIntoDigits(a * b0);
2955,String faktorDigits = splitIntoDigits(ab);
2956,return mulDigits.equals(faktorDigits);
2958,static String splitIntoDigits(int numint num2) {
2959,StringBuilder res = new StringBuilder();
2960,ArrayList<Integer> digits = new ArrayList<>();
2961,while (num > 0) {
2962,digits.add(num % 10);
2963,num /= 10;
2964,while (num2 > 0) {
2965,digits.add(num2 % 10);
2966,num2 /= 10;
2967,Collections.sort(digits);
2968,for (int i : digits) {
2969,res.append(i);
2970,return res.toString();
